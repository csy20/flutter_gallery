# Bucket Sort Algorithm in Dart - LeetCode Guide

## Table of Contents
1. [What is Bucket Sort?](#what-is-bucket-sort)
2. [How Bucket Sort Works](#how-bucket-sort-works)
3. [Algorithm Implementation](#algorithm-implementation)
4. [Variants and Optimizations](#variants-and-optimizations)
5. [LeetCode Problems](#leetcode-problems)
6. [Advanced Applications](#advanced-applications)
7. [Performance Analysis](#performance-analysis)
8. [Pro Tips](#pro-tips)

## What is Bucket Sort?

**Bucket Sort** is a distribution sorting algorithm that works by distributing elements into several buckets, then sorting these buckets individually, and finally concatenating the sorted buckets to get the final sorted array.

### Key Characteristics:
- **Non-comparison based**: Doesn't compare elements directly
- **Distribution sorting**: Elements are distributed into buckets
- **Average Time**: O(n + k) where k is the number of buckets
- **Space Complexity**: O(n + k)
- **Stable**: Can preserve relative order of equal elements
- **Best for**: Uniformly distributed data

### Visual Representation:
```
Input: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]

Step 1: Distribute into buckets (10 buckets for range [0, 1))
Bucket 0: []
Bucket 1: [0.17, 0.12]
Bucket 2: [0.26, 0.21, 0.23]
Bucket 3: [0.39]
Bucket 4: []
Bucket 5: []
Bucket 6: [0.68]
Bucket 7: [0.78, 0.72]
Bucket 8: []
Bucket 9: [0.94]

Step 2: Sort each bucket individually
Bucket 1: [0.12, 0.17]
Bucket 2: [0.21, 0.23, 0.26]
Bucket 3: [0.39]
Bucket 6: [0.68]
Bucket 7: [0.72, 0.78]
Bucket 9: [0.94]

Step 3: Concatenate buckets
Result: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

## How Bucket Sort Works

### Basic Algorithm Steps:

1. **Determine Range**: Find min and max values
2. **Create Buckets**: Initialize empty buckets
3. **Distribute**: Place each element in appropriate bucket
4. **Sort Buckets**: Sort each bucket individually
5. **Concatenate**: Combine sorted buckets

### Mathematical Foundation:
For n elements uniformly distributed over range [0, 1), using n buckets:
- Bucket index = floor(value Ã— n)
- Expected elements per bucket = 1
- Expected time per bucket = O(1)
- Total expected time = O(n)

## Algorithm Implementation

### 1. Basic Bucket Sort

```dart
import 'dart:math' as math;

class BucketSort {
  // Basic bucket sort for floating point numbers in range [0, 1)
  static List<double> sortFloats(List<double> arr) {
    if (arr.isEmpty) return [];
    
    int n = arr.length;
    
    // Create n empty buckets
    List<List<double>> buckets = List.generate(n, (_) => <double>[]);
    
    // Distribute elements into buckets
    for (double value in arr) {
      int bucketIndex = (value * n).floor();
      // Handle edge case where value = 1.0
      if (bucketIndex >= n) bucketIndex = n - 1;
      buckets[bucketIndex].add(value);
    }
    
    // Sort individual buckets (using insertion sort for small buckets)
    for (List<double> bucket in buckets) {
      _insertionSort(bucket);
    }
    
    // Concatenate sorted buckets
    List<double> result = [];
    for (List<double> bucket in buckets) {
      result.addAll(bucket);
    }
    
    return result;
  }
  
  static void _insertionSort(List<double> arr) {
    for (int i = 1; i < arr.length; i++) {
      double key = arr[i];
      int j = i - 1;
      
      while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = key;
    }
  }
}

// Example usage
void basicExample() {
  List<double> data = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68];
  
  print('Original: $data');
  List<double> sorted = BucketSort.sortFloats(data);
  print('Sorted: $sorted');
}
```

### 2. Generic Bucket Sort for Any Range

```dart
class GenericBucketSort {
  // Bucket sort for integers in any range
  static List<int> sortIntegers(List<int> arr, {int? numBuckets}) {
    if (arr.isEmpty) return [];
    
    // Find min and max values
    int minVal = arr.reduce(math.min);
    int maxVal = arr.reduce(math.max);
    
    if (minVal == maxVal) return List.from(arr);
    
    // Determine number of buckets
    numBuckets ??= math.sqrt(arr.length).ceil();
    double range = (maxVal - minVal + 1).toDouble();
    double bucketSize = range / numBuckets;
    
    // Create buckets
    List<List<int>> buckets = List.generate(numBuckets, (_) => <int>[]);
    
    // Distribute elements
    for (int value in arr) {
      int bucketIndex = ((value - minVal) / bucketSize).floor();
      if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;
      buckets[bucketIndex].add(value);
    }
    
    // Sort each bucket
    for (List<int> bucket in buckets) {
      bucket.sort();
    }
    
    // Concatenate results
    List<int> result = [];
    for (List<int> bucket in buckets) {
      result.addAll(bucket);
    }
    
    return result;
  }
  
  // Bucket sort for any comparable type
  static List<T> sortGeneric<T extends Comparable<T>>(
    List<T> arr,
    int Function(T) getIndex,
    int numBuckets
  ) {
    if (arr.isEmpty) return [];
    
    // Create buckets
    List<List<T>> buckets = List.generate(numBuckets, (_) => <T>[]);
    
    // Distribute elements
    for (T element in arr) {
      int bucketIndex = getIndex(element);
      if (bucketIndex >= 0 && bucketIndex < numBuckets) {
        buckets[bucketIndex].add(element);
      }
    }
    
    // Sort each bucket
    for (List<T> bucket in buckets) {
      bucket.sort();
    }
    
    // Concatenate results
    List<T> result = [];
    for (List<T> bucket in buckets) {
      result.addAll(bucket);
    }
    
    return result;
  }
}

// Example with custom objects
class Person implements Comparable<Person> {
  final String name;
  final int age;
  
  Person(this.name, this.age);
  
  @override
  int compareTo(Person other) => age.compareTo(other.age);
  
  @override
  String toString() => '$name($age)';
}

void genericExample() {
  List<int> numbers = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42];
  print('Original integers: $numbers');
  
  List<int> sorted = GenericBucketSort.sortIntegers(numbers);
  print('Sorted integers: $sorted');
  
  // Custom objects
  List<Person> people = [
    Person('Alice', 25),
    Person('Bob', 30),
    Person('Charlie', 20),
    Person('Diana', 35),
    Person('Eve', 22),
  ];
  
  List<Person> sortedPeople = GenericBucketSort.sortGeneric<Person>(
    people,
    (person) => person.age ~/ 10, // Bucket by decade
    4 // 4 buckets: 20s, 30s, etc.
  );
  
  print('Sorted people: $sortedPeople');
}
```

### 3. Optimized Bucket Sort with Adaptive Bucketing

```dart
class OptimizedBucketSort {
  // Adaptive bucket sort that adjusts bucket count based on data distribution
  static List<double> adaptiveBucketSort(List<double> arr) {
    if (arr.isEmpty || arr.length <= 1) return List.from(arr);
    
    // Analyze data distribution
    DistributionStats stats = _analyzeDistribution(arr);
    
    // Determine optimal bucket count
    int optimalBuckets = _calculateOptimalBuckets(arr.length, stats);
    
    // Create buckets with adaptive sizing
    List<BucketInfo> bucketInfos = _createAdaptiveBuckets(stats, optimalBuckets);
    List<List<double>> buckets = List.generate(optimalBuckets, (_) => <double>[]);
    
    // Distribute elements
    for (double value in arr) {
      int bucketIndex = _findBucketIndex(value, bucketInfos);
      buckets[bucketIndex].add(value);
    }
    
    // Sort buckets using optimal algorithm for each bucket size
    for (int i = 0; i < buckets.length; i++) {
      _sortBucketOptimally(buckets[i]);
    }
    
    // Concatenate results
    List<double> result = [];
    for (List<double> bucket in buckets) {
      result.addAll(bucket);
    }
    
    return result;
  }
  
  static DistributionStats _analyzeDistribution(List<double> arr) {
    double min = arr.reduce(math.min);
    double max = arr.reduce(math.max);
    double mean = arr.reduce((a, b) => a + b) / arr.length;
    
    double variance = 0;
    for (double value in arr) {
      variance += math.pow(value - mean, 2);
    }
    variance /= arr.length;
    double stdDev = math.sqrt(variance);
    
    return DistributionStats(min, max, mean, stdDev);
  }
  
  static int _calculateOptimalBuckets(int n, DistributionStats stats) {
    // Use statistical heuristics to determine bucket count
    double range = stats.max - stats.min;
    double avgBucketSize = 4.0; // Target average bucket size
    
    int buckets = (n / avgBucketSize).ceil();
    
    // Adjust based on distribution
    if (stats.stdDev > range * 0.3) {
      // High variance - use more buckets
      buckets = (buckets * 1.5).round();
    }
    
    return math.max(1, math.min(buckets, n));
  }
  
  static List<BucketInfo> _createAdaptiveBuckets(DistributionStats stats, int numBuckets) {
    List<BucketInfo> buckets = [];
    double range = stats.max - stats.min;
    double bucketSize = range / numBuckets;
    
    for (int i = 0; i < numBuckets; i++) {
      double start = stats.min + i * bucketSize;
      double end = (i == numBuckets - 1) ? stats.max + 0.0001 : start + bucketSize;
      buckets.add(BucketInfo(start, end));
    }
    
    return buckets;
  }
  
  static int _findBucketIndex(double value, List<BucketInfo> buckets) {
    for (int i = 0; i < buckets.length; i++) {
      if (value >= buckets[i].start && value < buckets[i].end) {
        return i;
      }
    }
    return buckets.length - 1; // Fallback to last bucket
  }
  
  static void _sortBucketOptimally(List<double> bucket) {
    if (bucket.length <= 10) {
      // Use insertion sort for small buckets
      _insertionSort(bucket);
    } else if (bucket.length <= 50) {
      // Use shell sort for medium buckets
      _shellSort(bucket);
    } else {
      // Use quick sort for large buckets
      bucket.sort();
    }
  }
  
  static void _insertionSort(List<double> arr) {
    for (int i = 1; i < arr.length; i++) {
      double key = arr[i];
      int j = i - 1;
      
      while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = key;
    }
  }
  
  static void _shellSort(List<double> arr) {
    int n = arr.length;
    
    for (int gap = n ~/ 2; gap > 0; gap ~/= 2) {
      for (int i = gap; i < n; i++) {
        double temp = arr[i];
        int j;
        
        for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
          arr[j] = arr[j - gap];
        }
        arr[j] = temp;
      }
    }
  }
}

class DistributionStats {
  final double min, max, mean, stdDev;
  DistributionStats(this.min, this.max, this.mean, this.stdDev);
}

class BucketInfo {
  final double start, end;
  BucketInfo(this.start, this.end);
}
```

## Variants and Optimizations

### 1. Radix Bucket Sort

```dart
class RadixBucketSort {
  // Sort integers using radix-based bucketing
  static List<int> radixBucketSort(List<int> arr) {
    if (arr.isEmpty) return [];
    
    // Find maximum number to determine number of digits
    int maxNum = arr.reduce(math.max);
    
    // Sort by each digit using bucket sort
    for (int exp = 1; maxNum ~/ exp > 0; exp *= 10) {
      _countingSortByDigit(arr, exp);
    }
    
    return arr;
  }
  
  static void _countingSortByDigit(List<int> arr, int exp) {
    int n = arr.length;
    List<int> output = List.filled(n, 0);
    List<int> count = List.filled(10, 0);
    
    // Count occurrences of each digit
    for (int i = 0; i < n; i++) {
      count[(arr[i] ~/ exp) % 10]++;
    }
    
    // Change count[i] to actual position
    for (int i = 1; i < 10; i++) {
      count[i] += count[i - 1];
    }
    
    // Build output array
    for (int i = n - 1; i >= 0; i--) {
      int digit = (arr[i] ~/ exp) % 10;
      output[count[digit] - 1] = arr[i];
      count[digit]--;
    }
    
    // Copy back to original array
    for (int i = 0; i < n; i++) {
      arr[i] = output[i];
    }
  }
}
```

### 2. Parallel Bucket Sort

```dart
import 'dart:isolate';

class ParallelBucketSort {
  // Parallel bucket sort using isolates
  static Future<List<double>> parallelSort(List<double> arr) async {
    if (arr.isEmpty || arr.length <= 100) {
      // Use sequential sort for small arrays
      return BucketSort.sortFloats(arr);
    }
    
    int numCores = 4; // Adjust based on available cores
    int bucketsPerCore = math.max(1, arr.length ~/ (numCores * 10));
    int totalBuckets = numCores * bucketsPerCore;
    
    // Create buckets
    List<List<double>> buckets = List.generate(totalBuckets, (_) => <double>[]);
    
    // Distribute elements
    for (double value in arr) {
      int bucketIndex = (value * totalBuckets).floor();
      if (bucketIndex >= totalBuckets) bucketIndex = totalBuckets - 1;
      buckets[bucketIndex].add(value);
    }
    
    // Group buckets for parallel processing
    List<List<List<double>>> bucketGroups = [];
    for (int i = 0; i < numCores; i++) {
      int start = i * bucketsPerCore;
      int end = math.min(start + bucketsPerCore, totalBuckets);
      bucketGroups.add(buckets.sublist(start, end));
    }
    
    // Sort buckets in parallel
    List<Future<List<double>>> futures = [];
    for (List<List<double>> group in bucketGroups) {
      futures.add(Isolate.run(() => _sortBucketGroup(group)));
    }
    
    List<List<double>> sortedGroups = await Future.wait(futures);
    
    // Concatenate results
    List<double> result = [];
    for (List<double> group in sortedGroups) {
      result.addAll(group);
    }
    
    return result;
  }
  
  static List<double> _sortBucketGroup(List<List<double>> bucketGroup) {
    List<double> result = [];
    
    for (List<double> bucket in bucketGroup) {
      if (bucket.isNotEmpty) {
        bucket.sort();
        result.addAll(bucket);
      }
    }
    
    return result;
  }
}
```

## LeetCode Problems

### 1. Maximum Gap (LeetCode 164)

```dart
class Solution164 {
  int maximumGap(List<int> nums) {
    if (nums.length < 2) return 0;
    
    // Use bucket sort approach
    int minVal = nums.reduce(math.min);
    int maxVal = nums.reduce(math.max);
    
    if (minVal == maxVal) return 0;
    
    int n = nums.length;
    
    // Calculate bucket size and count
    // For maximum gap, we need at least n-1 gaps
    // Pigeonhole principle: if we have n numbers in n-1 buckets,
    // at least one bucket will be empty, ensuring max gap >= bucket size
    int bucketSize = math.max(1, (maxVal - minVal) ~/ (n - 1));
    int bucketCount = (maxVal - minVal) ~/ bucketSize + 1;
    
    // Track min and max in each bucket (no need to store all elements)
    List<int?> bucketMin = List.filled(bucketCount, null);
    List<int?> bucketMax = List.filled(bucketCount, null);
    
    // Distribute numbers into buckets
    for (int num in nums) {
      int bucketIndex = (num - minVal) ~/ bucketSize;
      
      if (bucketMin[bucketIndex] == null) {
        bucketMin[bucketIndex] = num;
        bucketMax[bucketIndex] = num;
      } else {
        bucketMin[bucketIndex] = math.min(bucketMin[bucketIndex]!, num);
        bucketMax[bucketIndex] = math.max(bucketMax[bucketIndex]!, num);
      }
    }
    
    // Find maximum gap
    int maxGap = 0;
    int previousMax = minVal;
    
    for (int i = 0; i < bucketCount; i++) {
      if (bucketMin[i] != null) {
        // Gap is between previous max and current bucket min
        maxGap = math.max(maxGap, bucketMin[i]! - previousMax);
        previousMax = bucketMax[i]!;
      }
    }
    
    return maxGap;
  }
}

// Test example
void test164() {
  Solution164 solution = Solution164();
  
  List<int> nums1 = [3, 6, 9, 1];
  print('Maximum gap in $nums1: ${solution.maximumGap(nums1)}'); // 3
  
  List<int> nums2 = [10];
  print('Maximum gap in $nums2: ${solution.maximumGap(nums2)}'); // 0
  
  List<int> nums3 = [1, 1, 1, 1];
  print('Maximum gap in $nums3: ${solution.maximumGap(nums3)}'); // 0
}
```

### 2. Top K Frequent Elements (LeetCode 347) - Bucket Sort Approach

```dart
class Solution347 {
  List<int> topKFrequent(List<int> nums, int k) {
    // Count frequencies
    Map<int, int> frequency = {};
    for (int num in nums) {
      frequency[num] = (frequency[num] ?? 0) + 1;
    }
    
    // Use bucket sort where bucket index = frequency
    List<List<int>> buckets = List.generate(nums.length + 1, (_) => <int>[]);
    
    // Place numbers in buckets based on their frequency
    frequency.forEach((num, freq) {
      buckets[freq].add(num);
    });
    
    // Collect top k elements from highest frequency buckets
    List<int> result = [];
    
    for (int i = buckets.length - 1; i >= 0 && result.length < k; i--) {
      if (buckets[i].isNotEmpty) {
        for (int num in buckets[i]) {
          if (result.length < k) {
            result.add(num);
          }
        }
      }
    }
    
    return result;
  }
}

// Test example
void test347() {
  Solution347 solution = Solution347();
  
  List<int> nums1 = [1, 1, 1, 2, 2, 3];
  print('Top 2 frequent in $nums1: ${solution.topKFrequent(nums1, 2)}'); // [1, 2]
  
  List<int> nums2 = [1];
  print('Top 1 frequent in $nums2: ${solution.topKFrequent(nums2, 1)}'); // [1]
}
```

### 3. Sort Colors (LeetCode 75) - Bucket Sort Variant

```dart
class Solution75 {
  void sortColors(List<int> nums) {
    // Use counting sort (bucket sort for fixed range)
    List<int> buckets = [0, 0, 0]; // Count of 0s, 1s, 2s
    
    // Count occurrences
    for (int num in nums) {
      buckets[num]++;
    }
    
    // Reconstruct array
    int index = 0;
    for (int color = 0; color < 3; color++) {
      for (int count = 0; count < buckets[color]; count++) {
        nums[index++] = color;
      }
    }
  }
  
  // Alternative: Three-way partitioning (Dutch National Flag)
  void sortColorsThreeWay(List<int> nums) {
    int low = 0, mid = 0, high = nums.length - 1;
    
    while (mid <= high) {
      switch (nums[mid]) {
        case 0:
          _swap(nums, low++, mid++);
          break;
        case 1:
          mid++;
          break;
        case 2:
          _swap(nums, mid, high--);
          break;
      }
    }
  }
  
  void _swap(List<int> nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
}

// Test example
void test75() {
  Solution75 solution = Solution75();
  
  List<int> colors1 = [2, 0, 2, 1, 1, 0];
  print('Original colors: $colors1');
  solution.sortColors(colors1);
  print('Sorted colors: $colors1'); // [0, 0, 1, 1, 2, 2]
  
  List<int> colors2 = [2, 0, 1];
  print('Original colors: $colors2');
  solution.sortColorsThreeWay(colors2);
  print('Sorted colors: $colors2'); // [0, 1, 2]
}
```

### 4. H-Index (LeetCode 274) - Bucket Sort Application

```dart
class Solution274 {
  int hIndex(List<int> citations) {
    int n = citations.length;
    
    // Use bucket sort where bucket[i] contains count of papers with i citations
    // Papers with more than n citations go to bucket n
    List<int> buckets = List.filled(n + 1, 0);
    
    for (int citation in citations) {
      if (citation >= n) {
        buckets[n]++;
      } else {
        buckets[citation]++;
      }
    }
    
    // Calculate h-index by iterating from highest bucket
    int count = 0;
    for (int i = n; i >= 0; i--) {
      count += buckets[i];
      if (count >= i) {
        return i;
      }
    }
    
    return 0;
  }
}

// Test example
void test274() {
  Solution274 solution = Solution274();
  
  List<int> citations1 = [3, 0, 6, 1, 5];
  print('H-index for $citations1: ${solution.hIndex(citations1)}'); // 3
  
  List<int> citations2 = [1, 3, 1];
  print('H-index for $citations2: ${solution.hIndex(citations2)}'); // 1
}
```

### 5. Contains Duplicate III (LeetCode 220) - Bucket Approach

```dart
class Solution220 {
  bool containsNearbyAlmostDuplicate(List<int> nums, int indexDiff, int valueDiff) {
    if (indexDiff <= 0 || valueDiff < 0) return false;
    
    // Use bucket approach where bucket size = valueDiff + 1
    int bucketSize = valueDiff + 1;
    Map<int, int> buckets = {};
    
    for (int i = 0; i < nums.length; i++) {
      int bucketKey = _getBucketKey(nums[i], bucketSize);
      
      // Check current bucket
      if (buckets.containsKey(bucketKey)) {
        return true;
      }
      
      // Check adjacent buckets
      if (buckets.containsKey(bucketKey - 1) && 
          (nums[i] - buckets[bucketKey - 1]!).abs() <= valueDiff) {
        return true;
      }
      
      if (buckets.containsKey(bucketKey + 1) && 
          (nums[i] - buckets[bucketKey + 1]!).abs() <= valueDiff) {
        return true;
      }
      
      // Add current number to bucket
      buckets[bucketKey] = nums[i];
      
      // Remove numbers outside index window
      if (i >= indexDiff) {
        int oldBucketKey = _getBucketKey(nums[i - indexDiff], bucketSize);
        buckets.remove(oldBucketKey);
      }
    }
    
    return false;
  }
  
  int _getBucketKey(int num, int bucketSize) {
    // Handle negative numbers correctly
    return num < 0 ? (num + 1) ~/ bucketSize - 1 : num ~/ bucketSize;
  }
}

// Test example
void test220() {
  Solution220 solution = Solution220();
  
  List<int> nums1 = [1, 2, 3, 1];
  print('Contains nearby duplicate: ${solution.containsNearbyAlmostDuplicate(nums1, 3, 0)}'); // true
  
  List<int> nums2 = [1, 5, 9, 1, 5, 9];
  print('Contains nearby duplicate: ${solution.containsNearbyAlmostDuplicate(nums2, 2, 3)}'); // false
}
```

## Advanced Applications

### 1. Histogram-Based Image Processing

```dart
class HistogramBucketSort {
  // Sort pixels by intensity using bucket sort
  static List<int> sortPixelIntensities(List<int> pixels) {
    // Pixels have intensity values 0-255
    List<int> buckets = List.filled(256, 0);
    
    // Count pixel intensities
    for (int pixel in pixels) {
      if (pixel >= 0 && pixel < 256) {
        buckets[pixel]++;
      }
    }
    
    // Reconstruct sorted array
    List<int> sorted = [];
    for (int intensity = 0; intensity < 256; intensity++) {
      for (int count = 0; count < buckets[intensity]; count++) {
        sorted.add(intensity);
      }
    }
    
    return sorted;
  }
  
  // Histogram equalization using bucket sort
  static List<int> equalizeHistogram(List<int> pixels) {
    List<int> histogram = List.filled(256, 0);
    
    // Calculate histogram
    for (int pixel in pixels) {
      histogram[pixel]++;
    }
    
    // Calculate cumulative distribution
    List<int> cdf = List.filled(256, 0);
    cdf[0] = histogram[0];
    for (int i = 1; i < 256; i++) {
      cdf[i] = cdf[i - 1] + histogram[i];
    }
    
    // Normalize to 0-255 range
    int totalPixels = pixels.length;
    List<int> equalized = [];
    
    for (int pixel in pixels) {
      int newIntensity = ((cdf[pixel] * 255) / totalPixels).round();
      equalized.add(newIntensity);
    }
    
    return equalized;
  }
}
```

### 2. Time Series Data Bucketing

```dart
class TimeSeriesDataPoint {
  final DateTime timestamp;
  final double value;
  
  TimeSeriesDataPoint(this.timestamp, this.value);
  
  @override
  String toString() => '${timestamp.toIso8601String()}: $value';
}

class TimeSeriesBucketSort {
  // Bucket time series data by time intervals
  static Map<String, List<TimeSeriesDataPoint>> bucketByTimeInterval(
    List<TimeSeriesDataPoint> data,
    Duration bucketSize
  ) {
    if (data.isEmpty) return {};
    
    // Find time range
    DateTime minTime = data.map((d) => d.timestamp).reduce((a, b) => a.isBefore(b) ? a : b);
    DateTime maxTime = data.map((d) => d.timestamp).reduce((a, b) => a.isAfter(b) ? a : b);
    
    // Create time buckets
    Map<String, List<TimeSeriesDataPoint>> buckets = {};
    
    for (TimeSeriesDataPoint point in data) {
      Duration elapsed = point.timestamp.difference(minTime);
      int bucketIndex = elapsed.inMilliseconds ~/ bucketSize.inMilliseconds;
      String bucketKey = 'bucket_$bucketIndex';
      
      buckets.putIfAbsent(bucketKey, () => []);
      buckets[bucketKey]!.add(point);
    }
    
    // Sort each bucket by timestamp
    buckets.forEach((key, bucket) {
      bucket.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    });
    
    return buckets;
  }
  
  // Aggregate values in each time bucket
  static Map<String, double> aggregateByTimeInterval(
    List<TimeSeriesDataPoint> data,
    Duration bucketSize,
    double Function(List<double>) aggregator
  ) {
    Map<String, List<TimeSeriesDataPoint>> buckets = bucketByTimeInterval(data, bucketSize);
    Map<String, double> aggregated = {};
    
    buckets.forEach((key, bucket) {
      List<double> values = bucket.map((d) => d.value).toList();
      aggregated[key] = aggregator(values);
    });
    
    return aggregated;
  }
}

// Usage example
void timeSeriesExample() {
  List<TimeSeriesDataPoint> data = [
    TimeSeriesDataPoint(DateTime.now(), 10.5),
    TimeSeriesDataPoint(DateTime.now().add(Duration(minutes: 5)), 12.3),
    TimeSeriesDataPoint(DateTime.now().add(Duration(minutes: 15)), 8.7),
    TimeSeriesDataPoint(DateTime.now().add(Duration(minutes: 25)), 15.2),
  ];
  
  Map<String, List<TimeSeriesDataPoint>> buckets = 
      TimeSeriesBucketSort.bucketByTimeInterval(data, Duration(minutes: 10));
  
  print('Time buckets:');
  buckets.forEach((key, bucket) {
    print('$key: ${bucket.length} points');
  });
  
  // Calculate average per bucket
  Map<String, double> averages = TimeSeriesBucketSort.aggregateByTimeInterval(
    data,
    Duration(minutes: 10),
    (values) => values.reduce((a, b) => a + b) / values.length
  );
  
  print('Averages: $averages');
}
```

### 3. Geographic Data Bucketing

```dart
class GeoPoint {
  final double latitude;
  final double longitude;
  final String name;
  
  GeoPoint(this.latitude, this.longitude, this.name);
  
  @override
  String toString() => '$name($latitude, $longitude)';
}

class GeographicBucketSort {
  // Bucket geographic points by grid cells
  static Map<String, List<GeoPoint>> bucketByGeoGrid(
    List<GeoPoint> points,
    double gridSize // in degrees
  ) {
    Map<String, List<GeoPoint>> buckets = {};
    
    for (GeoPoint point in points) {
      int latGrid = (point.latitude / gridSize).floor();
      int lonGrid = (point.longitude / gridSize).floor();
      String bucketKey = '${latGrid}_$lonGrid';
      
      buckets.putIfAbsent(bucketKey, () => []);
      buckets[bucketKey]!.add(point);
    }
    
    return buckets;
  }
  
  // Find nearest neighbors using bucket approach
  static List<GeoPoint> findNearestNeighbors(
    GeoPoint target,
    List<GeoPoint> points,
    double gridSize,
    int maxResults
  ) {
    Map<String, List<GeoPoint>> buckets = bucketByGeoGrid(points, gridSize);
    
    int targetLatGrid = (target.latitude / gridSize).floor();
    int targetLonGrid = (target.longitude / gridSize).floor();
    
    List<GeoPoint> candidates = [];
    
    // Check target bucket and surrounding buckets
    for (int latOffset = -1; latOffset <= 1; latOffset++) {
      for (int lonOffset = -1; lonOffset <= 1; lonOffset++) {
        String bucketKey = '${targetLatGrid + latOffset}_${targetLonGrid + lonOffset}';
        if (buckets.containsKey(bucketKey)) {
          candidates.addAll(buckets[bucketKey]!);
        }
      }
    }
    
    // Calculate distances and sort
    List<DistancePoint> withDistances = candidates.map((point) {
      double distance = _calculateDistance(target, point);
      return DistancePoint(point, distance);
    }).toList();
    
    withDistances.sort((a, b) => a.distance.compareTo(b.distance));
    
    return withDistances
        .take(maxResults)
        .map((dp) => dp.point)
        .toList();
  }
  
  static double _calculateDistance(GeoPoint p1, GeoPoint p2) {
    // Simple Euclidean distance (not accurate for large distances)
    double dx = p1.latitude - p2.latitude;
    double dy = p1.longitude - p2.longitude;
    return math.sqrt(dx * dx + dy * dy);
  }
}

class DistancePoint {
  final GeoPoint point;
  final double distance;
  
  DistancePoint(this.point, this.distance);
}
```

## Performance Analysis

### Time Complexity Analysis:

```dart
class PerformanceAnalysis {
  static void analyzeComplexity() {
    print('Bucket Sort Complexity Analysis:');
    print('===============================');
    print('Best Case: O(n + k) where k = number of buckets');
    print('Average Case: O(n + k)');
    print('Worst Case: O(nÂ²) - when all elements go to one bucket');
    print('Space Complexity: O(n + k)');
    print('');
    print('Factors affecting performance:');
    print('- Data distribution (uniform is best)');
    print('- Number of buckets (optimal ~âˆšn)');
    print('- Choice of bucket sorting algorithm');
    print('');
  }
  
  static void benchmarkBucketSort() {
    List<int> sizes = [1000, 5000, 10000, 50000];
    
    for (int size in sizes) {
      print('Testing with $size elements:');
      
      // Test with uniform distribution
      List<double> uniformData = _generateUniformData(size);
      _testSortingPerformance('Uniform', uniformData);
      
      // Test with normal distribution
      List<double> normalData = _generateNormalData(size);
      _testSortingPerformance('Normal', normalData);
      
      // Test with skewed distribution
      List<double> skewedData = _generateSkewedData(size);
      _testSortingPerformance('Skewed', skewedData);
      
      print('');
    }
  }
  
  static void _testSortingPerformance(String distribution, List<double> data) {
    // Test bucket sort
    Stopwatch sw = Stopwatch()..start();
    List<double> bucketSorted = BucketSort.sortFloats(List.from(data));
    sw.stop();
    int bucketTime = sw.elapsedMicroseconds;
    
    // Test built-in sort
    sw.reset();
    sw.start();
    List<double> builtinSorted = List.from(data)..sort();
    sw.stop();
    int builtinTime = sw.elapsedMicroseconds;
    
    // Verify correctness
    bool correct = _listsEqual(bucketSorted, builtinSorted);
    
    print('  $distribution: Bucket=${bucketTime}Î¼s, Built-in=${builtinTime}Î¼s, Correct=$correct');
  }
  
  static List<double> _generateUniformData(int size) {
    return List.generate(size, (_) => math.Random().nextDouble());
  }
  
  static List<double> _generateNormalData(int size) {
    math.Random random = math.Random();
    return List.generate(size, (_) {
      // Box-Muller transform for normal distribution
      double u1 = random.nextDouble();
      double u2 = random.nextDouble();
      double z = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2);
      return (z + 3) / 6; // Normalize to [0, 1] approximately
    });
  }
  
  static List<double> _generateSkewedData(int size) {
    math.Random random = math.Random();
    return List.generate(size, (_) {
      double x = random.nextDouble();
      return math.pow(x, 3); // Skewed towards 0
    });
  }
  
  static bool _listsEqual(List<double> a, List<double> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if ((a[i] - b[i]).abs() > 1e-10) return false;
    }
    return true;
  }
}
```

## Pro Tips

### 1. **Choosing Optimal Bucket Count**

```dart
class BucketOptimization {
  // Heuristics for choosing bucket count
  static int calculateOptimalBuckets(int dataSize, double dataRange, String distribution) {
    int buckets;
    
    switch (distribution.toLowerCase()) {
      case 'uniform':
        // For uniform distribution, âˆšn buckets work well
        buckets = math.sqrt(dataSize).round();
        break;
        
      case 'normal':
        // For normal distribution, use more buckets in the center
        buckets = (dataSize / 4).round();
        break;
        
      case 'exponential':
        // For exponential distribution, use logarithmic bucketing
        buckets = (math.log(dataSize) * 10).round();
        break;
        
      default:
        // Conservative default
        buckets = math.max(1, dataSize ~/ 10);
    }
    
    return math.max(1, math.min(buckets, dataSize));
  }
  
  // Adaptive bucket sizing based on data analysis
  static List<double> calculateAdaptiveBucketBoundaries(List<double> sample) {
    sample.sort();
    int n = sample.length;
    
    if (n <= 10) {
      // For small samples, use quantile-based bucketing
      return _calculateQuantileBoundaries(sample, math.min(n, 5));
    }
    
    // Analyze distribution
    double mean = sample.reduce((a, b) => a + b) / n;
    double variance = sample.map((x) => math.pow(x - mean, 2)).reduce((a, b) => a + b) / n;
    double stdDev = math.sqrt(variance);
    
    // Check for uniformity
    double expectedSpacing = (sample.last - sample.first) / (n - 1);
    double actualSpacing = 0;
    for (int i = 1; i < n; i++) {
      actualSpacing += sample[i] - sample[i - 1];
    }
    actualSpacing /= (n - 1);
    
    double uniformityRatio = expectedSpacing / actualSpacing;
    
    if (uniformityRatio > 0.8 && uniformityRatio < 1.2) {
      // Data appears uniform, use equal-width buckets
      return _calculateEqualWidthBoundaries(sample.first, sample.last, 
                                           math.sqrt(n).round());
    } else {
      // Data is not uniform, use equal-frequency buckets
      return _calculateQuantileBoundaries(sample, math.sqrt(n).round());
    }
  }
  
  static List<double> _calculateEqualWidthBoundaries(double min, double max, int buckets) {
    List<double> boundaries = [];
    double width = (max - min) / buckets;
    
    for (int i = 0; i <= buckets; i++) {
      boundaries.add(min + i * width);
    }
    
    return boundaries;
  }
  
  static List<double> _calculateQuantileBoundaries(List<double> sortedData, int buckets) {
    List<double> boundaries = [];
    int n = sortedData.length;
    
    for (int i = 0; i <= buckets; i++) {
      double quantile = i / buckets;
      int index = (quantile * (n - 1)).round();
      boundaries.add(sortedData[index]);
    }
    
    return boundaries;
  }
}
```

### 2. **Memory-Efficient Implementation**

```dart
class MemoryEfficientBucketSort {
  // Sort large datasets with limited memory
  static void externalBucketSort(
    String inputFile,
    String outputFile,
    int memoryLimitMB
  ) {
    // This is a conceptual implementation
    // In practice, you'd read from actual files
    
    int memoryLimit = memoryLimitMB * 1024 * 1024 ~/ 8; // Approximate doubles
    
    // Phase 1: Create sorted chunks
    List<String> chunkFiles = _createSortedChunks(inputFile, memoryLimit);
    
    // Phase 2: Merge chunks using k-way merge
    _mergeChunks(chunkFiles, outputFile);
  }
  
  static List<String> _createSortedChunks(String inputFile, int chunkSize) {
    // Conceptual: read data in chunks, sort each chunk, write to temp files
    List<String> chunkFiles = [];
    
    // Implementation would read actual file data
    print('Creating sorted chunks with size limit: $chunkSize');
    
    return chunkFiles;
  }
  
  static void _mergeChunks(List<String> chunkFiles, String outputFile) {
    // Implementation would use k-way merge algorithm
    print('Merging ${chunkFiles.length} chunks into $outputFile');
  }
  
  // In-memory optimization: reuse bucket arrays
  static List<double> memoryOptimizedSort(List<double> data) {
    if (data.isEmpty) return [];
    
    int bucketCount = math.sqrt(data.length).round();
    
    // Use single array for all buckets to reduce memory allocation
    List<double> bucketData = [];
    List<int> bucketStarts = List.filled(bucketCount + 1, 0);
    List<int> bucketSizes = List.filled(bucketCount, 0);
    
    // First pass: count elements per bucket
    for (double value in data) {
      int bucketIndex = (value * bucketCount).floor();
      if (bucketIndex >= bucketCount) bucketIndex = bucketCount - 1;
      bucketSizes[bucketIndex]++;
    }
    
    // Calculate start positions
    for (int i = 1; i <= bucketCount; i++) {
      bucketStarts[i] = bucketStarts[i - 1] + bucketSizes[i - 1];
    }
    
    // Allocate single array for all bucket data
    bucketData = List.filled(data.length, 0.0);
    List<int> currentPos = List.from(bucketStarts);
    
    // Second pass: distribute elements
    for (double value in data) {
      int bucketIndex = (value * bucketCount).floor();
      if (bucketIndex >= bucketCount) bucketIndex = bucketCount - 1;
      bucketData[currentPos[bucketIndex]++] = value;
    }
    
    // Sort each bucket in place
    for (int i = 0; i < bucketCount; i++) {
      int start = bucketStarts[i];
      int end = bucketStarts[i + 1];
      if (end > start) {
        _insertionSortRange(bucketData, start, end - 1);
      }
    }
    
    return bucketData;
  }
  
  static void _insertionSortRange(List<double> arr, int start, int end) {
    for (int i = start + 1; i <= end; i++) {
      double key = arr[i];
      int j = i - 1;
      
      while (j >= start && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = key;
    }
  }
}
```

### 3. **Error Handling and Edge Cases**

```dart
class RobustBucketSort {
  static List<T> robustSort<T extends Comparable<T>>(
    List<T> data,
    double Function(T) getValue,
    {int? bucketCount}
  ) {
    // Input validation
    if (data.isEmpty) return [];
    if (data.length == 1) return List.from(data);
    
    try {
      // Find value range
      List<double> values = data.map(getValue).toList();
      double minVal = values.reduce(math.min);
      double maxVal = values.reduce(math.max);
      
      // Handle edge cases
      if (minVal == maxVal) {
        // All values are the same
        return List.from(data);
      }
      
      if (minVal.isNaN || maxVal.isNaN) {
        throw ArgumentError('Data contains NaN values');
      }
      
      if (minVal.isInfinite || maxVal.isInfinite) {
        throw ArgumentError('Data contains infinite values');
      }
      
      // Determine bucket count
      bucketCount ??= math.max(1, math.sqrt(data.length).round());
      bucketCount = math.min(bucketCount, data.length);
      
      // Create buckets
      List<List<T>> buckets = List.generate(bucketCount, (_) => <T>[]);
      double range = maxVal - minVal;
      
      // Distribute elements
      for (T element in data) {
        double value = getValue(element);
        int bucketIndex = ((value - minVal) / range * (bucketCount - 1)).round();
        bucketIndex = math.max(0, math.min(bucketIndex, bucketCount - 1));
        buckets[bucketIndex].add(element);
      }
      
      // Sort buckets and concatenate
      List<T> result = [];
      for (List<T> bucket in buckets) {
        if (bucket.isNotEmpty) {
          bucket.sort();
          result.addAll(bucket);
        }
      }
      
      return result;
      
    } catch (e) {
      print('Error in bucket sort: $e');
      // Fallback to built-in sort
      List<T> fallback = List.from(data);
      fallback.sort();
      return fallback;
    }
  }
  
  // Validate bucket sort result
  static bool validateSorted<T extends Comparable<T>>(List<T> original, List<T> sorted) {
    // Check length
    if (original.length != sorted.length) return false;
    
    // Check if sorted is actually sorted
    for (int i = 1; i < sorted.length; i++) {
      if (sorted[i - 1].compareTo(sorted[i]) > 0) return false;
    }
    
    // Check if same elements (counting)
    Map<T, int> originalCount = {};
    Map<T, int> sortedCount = {};
    
    for (T element in original) {
      originalCount[element] = (originalCount[element] ?? 0) + 1;
    }
    
    for (T element in sorted) {
      sortedCount[element] = (sortedCount[element] ?? 0) + 1;
    }
    
    return _mapsEqual(originalCount, sortedCount);
  }
  
  static bool _mapsEqual<K, V>(Map<K, V> map1, Map<K, V> map2) {
    if (map1.length != map2.length) return false;
    
    for (K key in map1.keys) {
      if (!map2.containsKey(key) || map1[key] != map2[key]) {
        return false;
      }
    }
    
    return true;
  }
}
```

## Summary

Bucket Sort is a powerful distribution sorting algorithm with these key characteristics:

**Core Concepts:**
- Distribute elements into buckets based on their values
- Sort each bucket individually
- Concatenate sorted buckets for final result

**Advantages:**
- **Linear average time**: O(n + k) for uniformly distributed data
- **Stable**: Can preserve relative order of equal elements
- **Parallelizable**: Buckets can be sorted independently
- **Flexible**: Works with various data types and distributions

**Best Use Cases:**
- Uniformly distributed floating-point numbers
- Data with known value ranges
- When comparison-based sorting is not ideal
- Frequency counting and histogram problems

**LeetCode Applications:**
- Maximum Gap: Using pigeonhole principle
- Top K Frequent Elements: Frequency-based bucketing
- Contains Duplicate III: Value difference bucketing
- H-Index: Citation count bucketing

**Implementation Considerations:**
- **Bucket count**: Optimal is usually âˆšn for uniform data
- **Bucket sorting**: Choose appropriate algorithm per bucket size
- **Memory usage**: O(n + k) space complexity
- **Edge cases**: Handle empty buckets, duplicate values, extreme ranges

**Performance Factors:**
- **Data distribution**: Uniform distribution gives best performance
- **Bucket count**: Too few causes uneven distribution, too many wastes space
- **Bucket sorting**: Choice affects performance for large buckets

**When to Use:**
- Data is approximately uniformly distributed
- Value range is known and reasonable
- Comparison-based sorting is not required
- Need stable sorting with good average performance

Master bucket sort to efficiently solve distribution-based problems and optimize sorting for specific data characteristics!