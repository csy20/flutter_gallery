# Strongly Connected Components Algorithm in Dart - LeetCode Guide

## Table of Contents
1. [What are Strongly Connected Components?](#what-are-strongly-connected-components)
2. [How SCC Algorithms Work](#how-scc-algorithms-work)
3. [Algorithm Implementations](#algorithm-implementations)
4. [Advanced Techniques](#advanced-techniques)
5. [LeetCode Problems](#leetcode-problems)
6. [Real-World Applications](#real-world-applications)
7. [Performance Analysis](#performance-analysis)
8. [Pro Tips](#pro-tips)

## What are Strongly Connected Components?

A **Strongly Connected Component (SCC)** is a maximal set of vertices in a directed graph where every vertex is reachable from every other vertex within that set. In other words, there's a directed path from any vertex to any other vertex in the same SCC.

### Key Concepts:

- **Directed Graph**: SCCs only apply to directed graphs
- **Mutual Reachability**: Every vertex can reach every other vertex in the same SCC
- **Maximal**: Cannot be extended by adding more vertices
- **Partition**: SCCs partition the graph into disjoint sets

### Visual Example:
```
Original Directed Graph:
    1 → 2 → 3
    ↑   ↓   ↓
    5 ← 4   6
    ↓       ↑
    7 → 8 → 9

Strongly Connected Components:
SCC 1: {1, 2, 4, 5} - All vertices can reach each other
SCC 2: {3}          - Single vertex
SCC 3: {6, 9}       - 6→9→6 forms a cycle
SCC 4: {7}          - Single vertex  
SCC 5: {8}          - Single vertex

Condensation Graph (SCCs as nodes):
SCC1 → SCC2
SCC1 → SCC4
SCC4 → SCC5
SCC5 → SCC3
```

### Properties:

1. **Transitivity**: If A can reach B and B can reach C, then A can reach C
2. **Reflexivity**: Every vertex can reach itself (within SCC)
3. **Symmetry**: If A can reach B in SCC, then B can reach A
4. **Maximality**: Adding any vertex breaks the strong connectivity

### Mathematical Definition:
For vertices u and v to be in the same SCC:
- There exists a path from u to v
- There exists a path from v to u
- This relation is an equivalence relation

## How SCC Algorithms Work

### 1. Kosaraju's Algorithm (Two-Pass DFS)

**Key Insight**: Reverse graph has same SCCs, but in reverse topological order.

**Steps**:
1. **First DFS**: Get finishing times (post-order) on original graph
2. **Transpose**: Create reverse graph (reverse all edges)
3. **Second DFS**: Run DFS on reverse graph in decreasing finish time order
4. **Result**: Each DFS tree in step 3 is one SCC

**Why it works**: 
- First DFS gives topological ordering of SCCs
- Second DFS on reverse graph processes SCCs in reverse topological order
- Each DFS tree in second pass is exactly one SCC

### 2. Tarjan's Algorithm (Single-Pass DFS)

**Key Insight**: Use DFS with low-link values to detect SCCs on-the-fly.

**Concepts**:
- **Discovery Time**: When vertex is first visited
- **Low-Link Value**: Smallest discovery time reachable from vertex
- **Stack**: Maintains current path being explored

**Steps**:
1. **DFS Traversal**: Visit vertices, maintain discovery times
2. **Low-Link Calculation**: For each vertex, calculate lowest reachable discovery time
3. **SCC Detection**: When low-link[v] == discovery[v], v is root of SCC
4. **Stack Pop**: Pop vertices until v to get complete SCC

### 3. Path-Based Algorithms

- **Gabow's Algorithm**: Uses two stacks for SCC detection
- **Dijkstra's Algorithm**: Early path-based approach

## Algorithm Implementations

### 1. Kosaraju's Algorithm

```dart
class KosarajuSCC {
  final int vertices;
  final List<List<int>> graph;
  final List<List<int>> reverseGraph;
  
  KosarajuSCC(this.vertices) 
    : graph = List.generate(vertices, (_) => <int>[]),
      reverseGraph = List.generate(vertices, (_) => <int>[]);
  
  void addEdge(int from, int to) {
    graph[from].add(to);
    reverseGraph[to].add(from);
  }
  
  List<List<int>> findSCCs() {
    // Step 1: First DFS to get finishing order
    List<bool> visited = List.filled(vertices, false);
    List<int> finishStack = [];
    
    for (int i = 0; i < vertices; i++) {
      if (!visited[i]) {
        _dfs1(i, visited, finishStack);
      }
    }
    
    // Step 2: DFS on reverse graph in reverse finishing order
    visited = List.filled(vertices, false);
    List<List<int>> sccs = [];
    
    while (finishStack.isNotEmpty) {
      int vertex = finishStack.removeLast();
      if (!visited[vertex]) {
        List<int> currentSCC = [];
        _dfs2(vertex, visited, currentSCC);
        sccs.add(currentSCC);
      }
    }
    
    return sccs;
  }
  
  // First DFS: Record finishing times
  void _dfs1(int vertex, List<bool> visited, List<int> finishStack) {
    visited[vertex] = true;
    
    for (int neighbor in graph[vertex]) {
      if (!visited[neighbor]) {
        _dfs1(neighbor, visited, finishStack);
      }
    }
    
    finishStack.add(vertex); // Add to stack when finished
  }
  
  // Second DFS: Find SCCs in reverse graph
  void _dfs2(int vertex, List<bool> visited, List<int> currentSCC) {
    visited[vertex] = true;
    currentSCC.add(vertex);
    
    for (int neighbor in reverseGraph[vertex]) {
      if (!visited[neighbor]) {
        _dfs2(neighbor, visited, currentSCC);
      }
    }
  }
  
  // Helper method to print SCCs
  void printSCCs() {
    List<List<int>> sccs = findSCCs();
    print('Strongly Connected Components (Kosaraju):');
    for (int i = 0; i < sccs.length; i++) {
      print('SCC ${i + 1}: ${sccs[i]}');
    }
  }
}

// Example usage
void kosarajuExample() {
  KosarajuSCC scc = KosarajuSCC(8);
  
  // Build the example graph
  scc.addEdge(0, 1); // 1 → 2
  scc.addEdge(1, 2); // 2 → 3
  scc.addEdge(2, 3); // 3 → 4
  scc.addEdge(3, 1); // 4 → 2
  scc.addEdge(1, 4); // 2 → 5
  scc.addEdge(4, 5); // 5 → 6
  scc.addEdge(5, 6); // 6 → 7
  scc.addEdge(6, 5); // 7 → 6
  scc.addEdge(6, 7); // 7 → 8
  
  scc.printSCCs();
}
```

### 2. Tarjan's Algorithm

```dart
class TarjanSCC {
  final int vertices;
  final List<List<int>> graph;
  
  late List<int> discovery;
  late List<int> lowLink;
  late List<bool> onStack;
  late List<int> stack;
  late List<bool> visited;
  late int time;
  late List<List<int>> sccs;
  
  TarjanSCC(this.vertices) : graph = List.generate(vertices, (_) => <int>[]);
  
  void addEdge(int from, int to) {
    graph[from].add(to);
  }
  
  List<List<int>> findSCCs() {
    // Initialize arrays
    discovery = List.filled(vertices, -1);
    lowLink = List.filled(vertices, -1);
    onStack = List.filled(vertices, false);
    visited = List.filled(vertices, false);
    stack = [];
    time = 0;
    sccs = [];
    
    // Run DFS from all unvisited vertices
    for (int i = 0; i < vertices; i++) {
      if (!visited[i]) {
        _tarjanDFS(i);
      }
    }
    
    return sccs;
  }
  
  void _tarjanDFS(int u) {
    // Initialize discovery time and low-link value
    discovery[u] = lowLink[u] = time++;
    visited[u] = true;
    stack.add(u);
    onStack[u] = true;
    
    // Recur for all adjacent vertices
    for (int v in graph[u]) {
      if (!visited[v]) {
        // Tree edge
        _tarjanDFS(v);
        lowLink[u] = math.min(lowLink[u], lowLink[v]);
      } else if (onStack[v]) {
        // Back edge to vertex on stack
        lowLink[u] = math.min(lowLink[u], discovery[v]);
      }
    }
    
    // If u is root of SCC, pop all vertices in this SCC
    if (lowLink[u] == discovery[u]) {
      List<int> currentSCC = [];
      int w;
      
      do {
        w = stack.removeLast();
        onStack[w] = false;
        currentSCC.add(w);
      } while (w != u);
      
      sccs.add(currentSCC);
    }
  }
  
  // Get SCC index for each vertex
  List<int> getSCCIndices() {
    List<List<int>> components = findSCCs();
    List<int> indices = List.filled(vertices, -1);
    
    for (int i = 0; i < components.length; i++) {
      for (int vertex in components[i]) {
        indices[vertex] = i;
      }
    }
    
    return indices;
  }
  
  // Check if two vertices are in same SCC
  bool inSameSCC(int u, int v) {
    List<int> indices = getSCCIndices();
    return indices[u] == indices[v];
  }
  
  void printSCCs() {
    List<List<int>> components = findSCCs();
    print('Strongly Connected Components (Tarjan):');
    for (int i = 0; i < components.length; i++) {
      print('SCC ${i + 1}: ${components[i]}');
    }
  }
}

// Example usage
void tarjanExample() {
  TarjanSCC scc = TarjanSCC(8);
  
  // Build the example graph
  scc.addEdge(0, 1);
  scc.addEdge(1, 2);
  scc.addEdge(2, 3);
  scc.addEdge(3, 1);
  scc.addEdge(1, 4);
  scc.addEdge(4, 5);
  scc.addEdge(5, 6);
  scc.addEdge(6, 5);
  scc.addEdge(6, 7);
  
  scc.printSCCs();
  
  // Check if vertices are in same SCC
  print('Vertices 1 and 3 in same SCC: ${scc.inSameSCC(1, 3)}');
  print('Vertices 1 and 5 in same SCC: ${scc.inSameSCC(1, 5)}');
}
```

### 3. Path-Based SCC (Gabow's Algorithm)

```dart
class GabowSCC {
  final int vertices;
  final List<List<int>> graph;
  
  late List<int> discovery;
  late List<int> pathStack;
  late List<int> boundaryStack;
  late List<bool> visited;
  late int time;
  late List<List<int>> sccs;
  
  GabowSCC(this.vertices) : graph = List.generate(vertices, (_) => <int>[]);
  
  void addEdge(int from, int to) {
    graph[from].add(to);
  }
  
  List<List<int>> findSCCs() {
    discovery = List.filled(vertices, -1);
    pathStack = [];
    boundaryStack = [];
    visited = List.filled(vertices, false);
    time = 0;
    sccs = [];
    
    for (int i = 0; i < vertices; i++) {
      if (!visited[i]) {
        _gabowDFS(i);
      }
    }
    
    return sccs;
  }
  
  void _gabowDFS(int u) {
    discovery[u] = time++;
    visited[u] = true;
    pathStack.add(u);
    boundaryStack.add(u);
    
    for (int v in graph[u]) {
      if (!visited[v]) {
        _gabowDFS(v);
      } else if (discovery[v] < discovery[boundaryStack.last]) {
        // Remove vertices from boundary stack while their discovery time
        // is greater than discovery time of v
        while (boundaryStack.isNotEmpty && 
               discovery[boundaryStack.last] > discovery[v]) {
          boundaryStack.removeLast();
        }
      }
    }
    
    // If u is at top of boundary stack, it's root of SCC
    if (boundaryStack.isNotEmpty && boundaryStack.last == u) {
      boundaryStack.removeLast();
      List<int> currentSCC = [];
      
      int w;
      do {
        w = pathStack.removeLast();
        currentSCC.add(w);
      } while (w != u);
      
      sccs.add(currentSCC);
    }
  }
  
  void printSCCs() {
    List<List<int>> components = findSCCs();
    print('Strongly Connected Components (Gabow):');
    for (int i = 0; i < components.length; i++) {
      print('SCC ${i + 1}: ${components[i]}');
    }
  }
}
```

## Advanced Techniques

### 1. SCC Condensation Graph

```dart
class SCCCondensation {
  final List<List<int>> originalGraph;
  final int vertices;
  
  SCCCondensation(this.originalGraph) : vertices = originalGraph.length;
  
  CondensationResult buildCondensation() {
    // Find SCCs using Tarjan's algorithm
    TarjanSCC tarjan = TarjanSCC(vertices);
    
    for (int i = 0; i < vertices; i++) {
      for (int neighbor in originalGraph[i]) {
        tarjan.addEdge(i, neighbor);
      }
    }
    
    List<List<int>> sccs = tarjan.findSCCs();
    List<int> sccIndices = tarjan.getSCCIndices();
    
    // Build condensation graph
    Set<String> edgeSet = {};
    List<List<int>> condensationGraph = List.generate(sccs.length, (_) => <int>[]);
    
    for (int u = 0; u < vertices; u++) {
      for (int v in originalGraph[u]) {
        int sccU = sccIndices[u];
        int sccV = sccIndices[v];
        
        if (sccU != sccV) {
          String edgeKey = '$sccU-$sccV';
          if (!edgeSet.contains(edgeKey)) {
            condensationGraph[sccU].add(sccV);
            edgeSet.add(edgeKey);
          }
        }
      }
    }
    
    return CondensationResult(sccs, sccIndices, condensationGraph);
  }
  
  // Check if condensation graph is DAG (always true for SCCs)
  bool isDAG(List<List<int>> graph) {
    List<int> color = List.filled(graph.length, 0); // 0: white, 1: gray, 2: black
    
    bool hasCycle(int vertex) {
      color[vertex] = 1; // Mark as being processed
      
      for (int neighbor in graph[vertex]) {
        if (color[neighbor] == 1) return true; // Back edge found
        if (color[neighbor] == 0 && hasCycle(neighbor)) return true;
      }
      
      color[vertex] = 2; // Mark as processed
      return false;
    }
    
    for (int i = 0; i < graph.length; i++) {
      if (color[i] == 0 && hasCycle(i)) {
        return false;
      }
    }
    
    return true;
  }
  
  // Topological sort of condensation graph
  List<int> topologicalSort(List<List<int>> graph) {
    List<int> inDegree = List.filled(graph.length, 0);
    
    // Calculate in-degrees
    for (int u = 0; u < graph.length; u++) {
      for (int v in graph[u]) {
        inDegree[v]++;
      }
    }
    
    // Kahn's algorithm
    Queue<int> queue = Queue();
    for (int i = 0; i < graph.length; i++) {
      if (inDegree[i] == 0) {
        queue.add(i);
      }
    }
    
    List<int> result = [];
    while (queue.isNotEmpty) {
      int u = queue.removeFirst();
      result.add(u);
      
      for (int v in graph[u]) {
        inDegree[v]--;
        if (inDegree[v] == 0) {
          queue.add(v);
        }
      }
    }
    
    return result;
  }
}

class CondensationResult {
  final List<List<int>> sccs;
  final List<int> sccIndices;
  final List<List<int>> condensationGraph;
  
  CondensationResult(this.sccs, this.sccIndices, this.condensationGraph);
  
  void printResult() {
    print('Original SCCs:');
    for (int i = 0; i < sccs.length; i++) {
      print('SCC $i: ${sccs[i]}');
    }
    
    print('\nCondensation Graph:');
    for (int i = 0; i < condensationGraph.length; i++) {
      if (condensationGraph[i].isNotEmpty) {
        print('SCC $i → ${condensationGraph[i]}');
      }
    }
  }
}
```

### 2. Online SCC Detection

```dart
class OnlineSCC {
  final int vertices;
  final List<List<int>> graph;
  late TarjanSCC _tarjan;
  bool _needsRecomputation = true;
  List<List<int>>? _cachedSCCs;
  
  OnlineSCC(this.vertices) : graph = List.generate(vertices, (_) => <int>[]);
  
  void addEdge(int from, int to) {
    graph[from].add(to);
    _needsRecomputation = true;
  }
  
  void removeEdge(int from, int to) {
    graph[from].remove(to);
    _needsRecomputation = true;
  }
  
  List<List<int>> getSCCs() {
    if (_needsRecomputation || _cachedSCCs == null) {
      _recomputeSCCs();
    }
    return _cachedSCCs!;
  }
  
  void _recomputeSCCs() {
    _tarjan = TarjanSCC(vertices);
    
    for (int i = 0; i < vertices; i++) {
      for (int neighbor in graph[i]) {
        _tarjan.addEdge(i, neighbor);
      }
    }
    
    _cachedSCCs = _tarjan.findSCCs();
    _needsRecomputation = false;
  }
  
  bool inSameSCC(int u, int v) {
    List<List<int>> sccs = getSCCs();
    
    for (List<int> scc in sccs) {
      if (scc.contains(u) && scc.contains(v)) {
        return true;
      }
    }
    
    return false;
  }
  
  // Get size of SCC containing vertex
  int getSCCSize(int vertex) {
    List<List<int>> sccs = getSCCs();
    
    for (List<int> scc in sccs) {
      if (scc.contains(vertex)) {
        return scc.length;
      }
    }
    
    return 1;
  }
  
  // Check if graph is strongly connected
  bool isStronglyConnected() {
    List<List<int>> sccs = getSCCs();
    return sccs.length == 1;
  }
}
```

### 3. Parallel SCC Detection

```dart
import 'dart:isolate';

class ParallelSCC {
  static Future<List<List<int>>> findSCCsParallel(
    int vertices, 
    List<List<int>> graph
  ) async {
    if (vertices < 1000) {
      // Use sequential for small graphs
      TarjanSCC tarjan = TarjanSCC(vertices);
      for (int i = 0; i < vertices; i++) {
        for (int neighbor in graph[i]) {
          tarjan.addEdge(i, neighbor);
        }
      }
      return tarjan.findSCCs();
    }
    
    // Divide graph into components for parallel processing
    List<Set<int>> components = _findWeaklyConnectedComponents(vertices, graph);
    
    List<Future<List<List<int>>>> futures = [];
    for (Set<int> component in components) {
      futures.add(_processSCCComponent(component, graph));
    }
    
    List<List<List<int>>> results = await Future.wait(futures);
    
    // Combine results
    List<List<int>> allSCCs = [];
    for (List<List<int>> componentSCCs in results) {
      allSCCs.addAll(componentSCCs);
    }
    
    return allSCCs;
  }
  
  static List<Set<int>> _findWeaklyConnectedComponents(
    int vertices, 
    List<List<int>> graph
  ) {
    // Convert to undirected graph for weakly connected components
    List<Set<int>> undirectedGraph = List.generate(vertices, (_) => <int>{});
    
    for (int i = 0; i < vertices; i++) {
      for (int neighbor in graph[i]) {
        undirectedGraph[i].add(neighbor);
        undirectedGraph[neighbor].add(i);
      }
    }
    
    List<bool> visited = List.filled(vertices, false);
    List<Set<int>> components = [];
    
    void dfs(int vertex, Set<int> component) {
      visited[vertex] = true;
      component.add(vertex);
      
      for (int neighbor in undirectedGraph[vertex]) {
        if (!visited[neighbor]) {
          dfs(neighbor, component);
        }
      }
    }
    
    for (int i = 0; i < vertices; i++) {
      if (!visited[i]) {
        Set<int> component = {};
        dfs(i, component);
        components.add(component);
      }
    }
    
    return components;
  }
  
  static Future<List<List<int>>> _processSCCComponent(
    Set<int> component, 
    List<List<int>> originalGraph
  ) async {
    // Extract subgraph for this component
    List<int> vertices = component.toList();
    Map<int, int> vertexMap = {};
    
    for (int i = 0; i < vertices.length; i++) {
      vertexMap[vertices[i]] = i;
    }
    
    return Isolate.run(() => _computeSCCForComponent(vertices, vertexMap, originalGraph));
  }
  
  static List<List<int>> _computeSCCForComponent(
    List<int> vertices,
    Map<int, int> vertexMap,
    List<List<int>> originalGraph
  ) {
    int n = vertices.length;
    TarjanSCC tarjan = TarjanSCC(n);
    
    // Build subgraph
    for (int i = 0; i < vertices.length; i++) {
      int originalVertex = vertices[i];
      for (int neighbor in originalGraph[originalVertex]) {
        if (vertexMap.containsKey(neighbor)) {
          tarjan.addEdge(i, vertexMap[neighbor]!);
        }
      }
    }
    
    // Find SCCs and map back to original vertices
    List<List<int>> sccs = tarjan.findSCCs();
    List<List<int>> mappedSCCs = [];
    
    for (List<int> scc in sccs) {
      List<int> mappedSCC = scc.map((v) => vertices[v]).toList();
      mappedSCCs.add(mappedSCC);
    }
    
    return mappedSCCs;
  }
}
```

## LeetCode Problems

### 1. Course Schedule II (LeetCode 210) - SCC Application

```dart
class Solution210 {
  List<int> findOrder(int numCourses, List<List<int>> prerequisites) {
    // Build graph
    List<List<int>> graph = List.generate(numCourses, (_) => <int>[]);
    List<int> inDegree = List.filled(numCourses, 0);
    
    for (List<int> prereq in prerequisites) {
      int course = prereq[0];
      int prerequisite = prereq[1];
      graph[prerequisite].add(course);
      inDegree[course]++;
    }
    
    // Check for strongly connected components (cycles)
    if (_hasCycle(graph)) {
      return []; // Impossible to finish all courses
    }
    
    // Kahn's algorithm for topological sorting
    Queue<int> queue = Queue();
    for (int i = 0; i < numCourses; i++) {
      if (inDegree[i] == 0) {
        queue.add(i);
      }
    }
    
    List<int> result = [];
    while (queue.isNotEmpty) {
      int course = queue.removeFirst();
      result.add(course);
      
      for (int nextCourse in graph[course]) {
        inDegree[nextCourse]--;
        if (inDegree[nextCourse] == 0) {
          queue.add(nextCourse);
        }
      }
    }
    
    return result.length == numCourses ? result : [];
  }
  
  bool _hasCycle(List<List<int>> graph) {
    int n = graph.length;
    List<int> color = List.filled(n, 0); // 0: white, 1: gray, 2: black
    
    bool dfs(int vertex) {
      color[vertex] = 1; // Mark as being processed
      
      for (int neighbor in graph[vertex]) {
        if (color[neighbor] == 1) return true; // Back edge - cycle found
        if (color[neighbor] == 0 && dfs(neighbor)) return true;
      }
      
      color[vertex] = 2; // Mark as processed
      return false;
    }
    
    for (int i = 0; i < n; i++) {
      if (color[i] == 0 && dfs(i)) {
        return true;
      }
    }
    
    return false;
  }
}

// Test example
void test210() {
  Solution210 solution = Solution210();
  
  List<List<int>> prerequisites1 = [
    [1, 0],
    [2, 0],
    [3, 1],
    [3, 2]
  ];
  print('Course order for 4 courses: ${solution.findOrder(4, prerequisites1)}');
  
  List<List<int>> prerequisites2 = [
    [1, 0],
    [0, 1]
  ];
  print('Course order with cycle: ${solution.findOrder(2, prerequisites2)}');
}
```

### 2. Critical Connections in a Network (LeetCode 1192) - Tarjan's Bridges

```dart
class Solution1192 {
  List<List<int>> criticalConnections(int n, List<List<int>> connections) {
    // Build adjacency list
    List<List<int>> graph = List.generate(n, (_) => <int>[]);
    for (List<int> conn in connections) {
      graph[conn[0]].add(conn[1]);
      graph[conn[1]].add(conn[0]);
    }
    
    List<int> discovery = List.filled(n, -1);
    List<int> low = List.filled(n, -1);
    List<int> parent = List.filled(n, -1);
    List<List<int>> bridges = [];
    int time = 0;
    
    void bridgeUtil(int u) {
      discovery[u] = low[u] = time++;
      
      for (int v in graph[u]) {
        if (discovery[v] == -1) {
          parent[v] = u;
          bridgeUtil(v);
          
          low[u] = math.min(low[u], low[v]);
          
          // Bridge condition
          if (low[v] > discovery[u]) {
            bridges.add([u, v]);
          }
        } else if (v != parent[u]) {
          low[u] = math.min(low[u], discovery[v]);
        }
      }
    }
    
    for (int i = 0; i < n; i++) {
      if (discovery[i] == -1) {
        bridgeUtil(i);
      }
    }
    
    return bridges;
  }
}

// Test example
void test1192() {
  Solution1192 solution = Solution1192();
  
  List<List<int>> connections = [
    [0, 1],
    [1, 2],
    [2, 0],
    [1, 3]
  ];
  print('Critical connections: ${solution.criticalConnections(4, connections)}');
}
```

### 3. Satisfiability of Equality Equations (LeetCode 990) - SCC Application

```dart
class Solution990 {
  bool equationsPossible(List<String> equations) {
    // Separate equality and inequality equations
    List<String> equalities = [];
    List<String> inequalities = [];
    
    for (String eq in equations) {
      if (eq[1] == '=') {
        equalities.add(eq);
      } else {
        inequalities.add(eq);
      }
    }
    
    // Build graph from equalities
    Map<String, List<String>> graph = {};
    
    for (String eq in equalities) {
      String a = eq[0];
      String b = eq[3];
      
      graph.putIfAbsent(a, () => []).add(b);
      graph.putIfAbsent(b, () => []).add(a);
    }
    
    // Find connected components (equivalence classes)
    Map<String, String> parent = {};
    
    String find(String x) {
      if (!parent.containsKey(x)) {
        parent[x] = x;
      }
      if (parent[x] != x) {
        parent[x] = find(parent[x]!);
      }
      return parent[x]!;
    }
    
    void union(String x, String y) {
      String rootX = find(x);
      String rootY = find(y);
      if (rootX != rootY) {
        parent[rootX] = rootY;
      }
    }
    
    // Process equalities
    for (String eq in equalities) {
      String a = eq[0];
      String b = eq[3];
      union(a, b);
    }
    
    // Check inequalities
    for (String eq in inequalities) {
      String a = eq[0];
      String b = eq[3];
      
      if (find(a) == find(b)) {
        return false; // Contradiction found
      }
    }
    
    return true;
  }
}

// Test example
void test990() {
  Solution990 solution = Solution990();
  
  List<String> equations1 = ["a==b", "b!=a"];
  print('Equations possible: ${solution.equationsPossible(equations1)}'); // false
  
  List<String> equations2 = ["b==a", "a==b"];
  print('Equations possible: ${solution.equationsPossible(equations2)}'); // true
  
  List<String> equations3 = ["a==b", "b==c", "a!=c"];
  print('Equations possible: ${solution.equationsPossible(equations3)}'); // false
}
```

### 4. Redundant Connection II (LeetCode 685) - SCC for Directed Graphs

```dart
class Solution685 {
  List<int> findRedundantDirectedConnection(List<List<int>> edges) {
    int n = edges.length;
    List<int> parent = List.filled(n + 1, 0);
    List<int> candidate1 = [];
    List<int> candidate2 = [];
    
    // Step 1: Check if there's a node with in-degree 2
    for (List<int> edge in edges) {
      int child = edge[1];
      
      if (parent[child] == 0) {
        parent[child] = edge[0];
      } else {
        // Node with in-degree 2 found
        candidate1 = [parent[child], child];
        candidate2 = edge;
        edge[1] = 0; // Temporarily remove this edge
      }
    }
    
    // Step 2: Use Union-Find to detect cycle
    for (int i = 1; i <= n; i++) {
      parent[i] = i;
    }
    
    int find(int x) {
      if (parent[x] != x) {
        parent[x] = find(parent[x]);
      }
      return parent[x];
    }
    
    for (List<int> edge in edges) {
      if (edge[1] == 0) continue; // Skip removed edge
      
      int rootU = find(edge[0]);
      int rootV = find(edge[1]);
      
      if (rootU == rootV) {
        // Cycle detected
        return candidate1.isEmpty ? edge : candidate1;
      }
      
      parent[rootV] = rootU;
    }
    
    // No cycle detected, return candidate2
    return candidate2;
  }
}

// Test example
void test685() {
  Solution685 solution = Solution685();
  
  List<List<int>> edges1 = [
    [1, 2],
    [1, 3],
    [2, 3]
  ];
  print('Redundant connection: ${solution.findRedundantDirectedConnection(edges1)}');
  
  List<List<int>> edges2 = [
    [1, 2],
    [2, 3],
    [3, 4],
    [4, 1],
    [1, 5]
  ];
  print('Redundant connection: ${solution.findRedundantDirectedConnection(edges2)}');
}
```

### 5. Minimum Number of Vertices to Reach All Nodes (LeetCode 1557)

```dart
class Solution1557 {
  List<int> findSmallestSetOfVertices(int n, List<List<int>> edges) {
    // Find all nodes with in-degree 0
    List<bool> hasIncomingEdge = List.filled(n, false);
    
    for (List<int> edge in edges) {
      hasIncomingEdge[edge[1]] = true;
    }
    
    List<int> result = [];
    for (int i = 0; i < n; i++) {
      if (!hasIncomingEdge[i]) {
        result.add(i);
      }
    }
    
    return result;
  }
  
  // Alternative approach using SCC
  List<int> findSmallestSetUsingSCC(int n, List<List<int>> edges) {
    // Build graph
    TarjanSCC scc = TarjanSCC(n);
    for (List<int> edge in edges) {
      scc.addEdge(edge[0], edge[1]);
    }
    
    List<List<int>> components = scc.findSCCs();
    List<int> sccIndices = scc.getSCCIndices();
    
    // Build condensation graph
    Set<int> hasIncomingEdge = {};
    for (List<int> edge in edges) {
      int sccU = sccIndices[edge[0]];
      int sccV = sccIndices[edge[1]];
      if (sccU != sccV) {
        hasIncomingEdge.add(sccV);
      }
    }
    
    // Find SCCs with no incoming edges
    List<int> result = [];
    for (int i = 0; i < components.length; i++) {
      if (!hasIncomingEdge.contains(i)) {
        // Add one representative from each source SCC
        result.add(components[i][0]);
      }
    }
    
    return result;
  }
}

// Test example
void test1557() {
  Solution1557 solution = Solution1557();
  
  List<List<int>> edges1 = [
    [0, 1],
    [2, 1],
    [3, 0],
    [2, 4]
  ];
  print('Smallest set of vertices: ${solution.findSmallestSetOfVertices(6, edges1)}');
  
  List<List<int>> edges2 = [
    [0, 1],
    [0, 2],
    [2, 5],
    [3, 4],
    [4, 2]
  ];
  print('Smallest set of vertices: ${solution.findSmallestSetOfVertices(6, edges2)}');
}
```

## Real-World Applications

### 1. Social Network Analysis

```dart
class SocialNetworkAnalyzer {
  final Map<String, List<String>> followGraph;
  
  SocialNetworkAnalyzer(this.followGraph);
  
  // Find mutual follow groups (strongly connected components)
  List<List<String>> findMutualFollowGroups() {
    Map<String, int> userToIndex = {};
    List<String> indexToUser = [];
    
    // Create mappings
    int index = 0;
    for (String user in followGraph.keys) {
      if (!userToIndex.containsKey(user)) {
        userToIndex[user] = index++;
        indexToUser.add(user);
      }
      for (String follower in followGraph[user]!) {
        if (!userToIndex.containsKey(follower)) {
          userToIndex[follower] = index++;
          indexToUser.add(follower);
        }
      }
    }
    
    // Build SCC
    TarjanSCC scc = TarjanSCC(index);
    followGraph.forEach((user, followers) {
      int userIndex = userToIndex[user]!;
      for (String follower in followers) {
        int followerIndex = userToIndex[follower]!;
        scc.addEdge(userIndex, followerIndex);
      }
    });
    
    List<List<int>> components = scc.findSCCs();
    
    // Convert back to user names
    return components.map((component) => 
        component.map((index) => indexToUser[index]).toList()
    ).toList();
  }
  
  // Find influential users (users in large SCCs or with many outgoing edges)
  List<String> findInfluentialUsers() {
    List<List<String>> mutualGroups = findMutualFollowGroups();
    
    List<String> influential = [];
    
    // Users in large mutual groups are influential
    for (List<String> group in mutualGroups) {
      if (group.length >= 3) {
        influential.addAll(group);
      }
    }
    
    // Users with many followers
    followGraph.forEach((user, followers) {
      if (followers.length >= 10) {
        influential.add(user);
      }
    });
    
    return influential.toSet().toList();
  }
}
```

### 2. Web Page Ranking and Link Analysis

```dart
class WebGraphAnalyzer {
  final Map<String, List<String>> linkGraph;
  
  WebGraphAnalyzer(this.linkGraph);
  
  // Find web communities (strongly connected components)
  List<List<String>> findWebCommunities() {
    Map<String, int> urlToIndex = {};
    List<String> indexToUrl = [];
    
    int index = 0;
    for (String url in linkGraph.keys) {
      if (!urlToIndex.containsKey(url)) {
        urlToIndex[url] = index++;
        indexToUrl.add(url);
      }
      for (String linkedUrl in linkGraph[url]!) {
        if (!urlToIndex.containsKey(linkedUrl)) {
          urlToIndex[linkedUrl] = index++;
          indexToUrl.add(linkedUrl);
        }
      }
    }
    
    TarjanSCC scc = TarjanSCC(index);
    linkGraph.forEach((url, links) {
      int urlIndex = urlToIndex[url]!;
      for (String linkedUrl in links) {
        int linkedIndex = urlToIndex[linkedUrl]!;
        scc.addEdge(urlIndex, linkedIndex);
      }
    });
    
    List<List<int>> components = scc.findSCCs();
    
    return components.map((component) => 
        component.map((index) => indexToUrl[index]).toList()
    ).toList();
  }
  
  // Simple PageRank implementation
  Map<String, double> calculatePageRank({double dampingFactor = 0.85, int iterations = 100}) {
    Map<String, double> pageRank = {};
    Set<String> allUrls = {};
    
    // Collect all URLs
    linkGraph.forEach((url, links) {
      allUrls.add(url);
      allUrls.addAll(links);
    });
    
    // Initialize PageRank values
    double initialValue = 1.0 / allUrls.length;
    for (String url in allUrls) {
      pageRank[url] = initialValue;
    }
    
    // PageRank iterations
    for (int i = 0; i < iterations; i++) {
      Map<String, double> newPageRank = {};
      
      for (String url in allUrls) {
        newPageRank[url] = (1.0 - dampingFactor) / allUrls.length;
      }
      
      linkGraph.forEach((fromUrl, toUrls) {
        double contribution = pageRank[fromUrl]! / toUrls.length;
        for (String toUrl in toUrls) {
          newPageRank[toUrl] = (newPageRank[toUrl] ?? 0) + dampingFactor * contribution;
        }
      });
      
      pageRank = newPageRank;
    }
    
    return pageRank;
  }
}
```

### 3. Compiler and Program Analysis

```dart
class CallGraphAnalyzer {
  final Map<String, List<String>> callGraph;
  
  CallGraphAnalyzer(this.callGraph);
  
  // Find recursive function groups
  List<List<String>> findRecursiveFunctionGroups() {
    Map<String, int> functionToIndex = {};
    List<String> indexToFunction = [];
    
    int index = 0;
    for (String function in callGraph.keys) {
      if (!functionToIndex.containsKey(function)) {
        functionToIndex[function] = index++;
        indexToFunction.add(function);
      }
      for (String calledFunction in callGraph[function]!) {
        if (!functionToIndex.containsKey(calledFunction)) {
          functionToIndex[calledFunction] = index++;
          indexToFunction.add(calledFunction);
        }
      }
    }
    
    TarjanSCC scc = TarjanSCC(index);
    callGraph.forEach((function, calledFunctions) {
      int functionIndex = functionToIndex[function]!;
      for (String calledFunction in calledFunctions) {
        int calledIndex = functionToIndex[calledFunction]!;
        scc.addEdge(functionIndex, calledIndex);
      }
    });
    
    List<List<int>> components = scc.findSCCs();
    
    // Filter out single-function components unless they're self-recursive
    return components.where((component) {
      if (component.length > 1) return true;
      
      String function = indexToFunction[component[0]];
      return callGraph[function]?.contains(function) ?? false;
    }).map((component) => 
        component.map((index) => indexToFunction[index]).toList()
    ).toList();
  }
  
  // Detect potential infinite recursion
  List<String> detectPotentialInfiniteRecursion() {
    List<List<String>> recursiveGroups = findRecursiveFunctionGroups();
    List<String> risky = [];
    
    for (List<String> group in recursiveGroups) {
      // Simple heuristic: groups with many functions are more likely to have issues
      if (group.length > 5) {
        risky.addAll(group);
      }
      
      // Check for direct self-recursion without base cases (simplified)
      for (String function in group) {
        if (group.length == 1 && callGraph[function]?.contains(function) == true) {
          risky.add(function);
        }
      }
    }
    
    return risky;
  }
}
```

## Performance Analysis

### Time Complexity:

| Algorithm | Time Complexity | Space Complexity | Best Use Case |
|-----------|----------------|------------------|---------------|
| Kosaraju's | O(V + E) | O(V + E) | Simple implementation |
| Tarjan's | O(V + E) | O(V) | Memory efficient |
| Gabow's | O(V + E) | O(V) | Path-based approach |

Where:
- V = number of vertices
- E = number of edges

### Space Complexity Details:

- **Kosaraju's**: O(V + E) for adjacency lists + O(V) for reverse graph
- **Tarjan's**: O(V) for discovery, low-link, and stack arrays
- **Gabow's**: O(V) for path and boundary stacks

### Practical Performance:

```dart
class SCCBenchmark {
  static void runBenchmarks() {
    print('SCC Algorithm Benchmarks');
    print('=' * 40);
    
    List<int> sizes = [100, 500, 1000, 5000, 10000];
    
    for (int size in sizes) {
      _benchmarkSize(size);
    }
  }
  
  static void _benchmarkSize(int vertices) {
    // Generate random directed graph
    List<List<int>> graph = _generateRandomGraph(vertices, (vertices * 1.5).round());
    
    // Benchmark Kosaraju
    Stopwatch sw = Stopwatch()..start();
    KosarajuSCC kosaraju = KosarajuSCC(vertices);
    for (int i = 0; i < graph.length; i++) {
      for (int neighbor in graph[i]) {
        kosaraju.addEdge(i, neighbor);
      }
    }
    List<List<int>> kosarajuResult = kosaraju.findSCCs();
    sw.stop();
    double kosarajuTime = sw.elapsedMicroseconds / 1000.0;
    
    // Benchmark Tarjan
    sw.reset();
    sw.start();
    TarjanSCC tarjan = TarjanSCC(vertices);
    for (int i = 0; i < graph.length; i++) {
      for (int neighbor in graph[i]) {
        tarjan.addEdge(i, neighbor);
      }
    }
    List<List<int>> tarjanResult = tarjan.findSCCs();
    sw.stop();
    double tarjanTime = sw.elapsedMicroseconds / 1000.0;
    
    print('Vertices: $vertices');
    print('  Kosaraju: ${kosarajuTime.toStringAsFixed(2)}ms, SCCs: ${kosarajuResult.length}');
    print('  Tarjan: ${tarjanTime.toStringAsFixed(2)}ms, SCCs: ${tarjanResult.length}');
    print('  Speedup: ${(kosarajuTime / tarjanTime).toStringAsFixed(2)}x');
    print('');
  }
  
  static List<List<int>> _generateRandomGraph(int vertices, int edges) {
    List<List<int>> graph = List.generate(vertices, (_) => <int>[]);
    math.Random random = math.Random();
    
    for (int i = 0; i < edges; i++) {
      int from = random.nextInt(vertices);
      int to = random.nextInt(vertices);
      if (!graph[from].contains(to)) {
        graph[from].add(to);
      }
    }
    
    return graph;
  }
}
```

## Pro Tips

### 1. Algorithm Selection Guide

```dart
class SCCAlgorithmSelector {
  static String recommendAlgorithm(GraphProperties properties) {
    if (properties.memoryConstrained) {
      return 'Tarjan\'s Algorithm - Most memory efficient';
    }
    
    if (properties.needsSimpleImplementation) {
      return 'Kosaraju\'s Algorithm - Easiest to understand and implement';
    }
    
    if (properties.requiresOnlineProcessing) {
      return 'Modified Tarjan\'s - Can handle dynamic graphs';
    }
    
    if (properties.hasLargeGraph && properties.canParallelize) {
      return 'Parallel SCC - Divide weakly connected components';
    }
    
    if (properties.needsPathInformation) {
      return 'Gabow\'s Algorithm - Path-based approach';
    }
    
    return 'Tarjan\'s Algorithm - Best overall performance';
  }
}

class GraphProperties {
  final bool memoryConstrained;
  final bool needsSimpleImplementation;
  final bool requiresOnlineProcessing;
  final bool hasLargeGraph;
  final bool canParallelize;
  final bool needsPathInformation;
  
  GraphProperties({
    this.memoryConstrained = false,
    this.needsSimpleImplementation = false,
    this.requiresOnlineProcessing = false,
    this.hasLargeGraph = false,
    this.canParallelize = false,
    this.needsPathInformation = false,
  });
}
```

### 2. Common Patterns and Templates

```dart
class SCCLeetCodeTemplates {
  // Template 1: Cycle detection in directed graph
  static bool hasCycle(List<List<int>> graph) {
    int n = graph.length;
    List<int> color = List.filled(n, 0); // 0: white, 1: gray, 2: black
    
    bool dfs(int vertex) {
      color[vertex] = 1;
      
      for (int neighbor in graph[vertex]) {
        if (color[neighbor] == 1) return true; // Back edge
        if (color[neighbor] == 0 && dfs(neighbor)) return true;
      }
      
      color[vertex] = 2;
      return false;
    }
    
    for (int i = 0; i < n; i++) {
      if (color[i] == 0 && dfs(i)) return true;
    }
    
    return false;
  }
  
  // Template 2: Topological sort with SCC validation
  static List<int>? topologicalSort(List<List<int>> graph) {
    if (hasCycle(graph)) return null;
    
    int n = graph.length;
    List<int> inDegree = List.filled(n, 0);
    
    for (int i = 0; i < n; i++) {
      for (int neighbor in graph[i]) {
        inDegree[neighbor]++;
      }
    }
    
    Queue<int> queue = Queue();
    for (int i = 0; i < n; i++) {
      if (inDegree[i] == 0) queue.add(i);
    }
    
    List<int> result = [];
    while (queue.isNotEmpty) {
      int vertex = queue.removeFirst();
      result.add(vertex);
      
      for (int neighbor in graph[vertex]) {
        inDegree[neighbor]--;
        if (inDegree[neighbor] == 0) queue.add(neighbor);
      }
    }
    
    return result.length == n ? result : null;
  }
  
  // Template 3: Find all vertices in same SCC
  static bool inSameSCC(int u, int v, List<List<int>> graph) {
    TarjanSCC scc = TarjanSCC(graph.length);
    
    for (int i = 0; i < graph.length; i++) {
      for (int neighbor in graph[i]) {
        scc.addEdge(i, neighbor);
      }
    }
    
    return scc.inSameSCC(u, v);
  }
}
```

### 3. Edge Cases and Error Handling

```dart
class SCCEdgeCaseHandler {
  static List<List<int>> robustFindSCCs(List<List<int>> graph) {
    if (graph.isEmpty) return [];
    
    int n = graph.length;
    
    // Validate graph structure
    for (int i = 0; i < n; i++) {
      for (int neighbor in graph[i]) {
        if (neighbor < 0 || neighbor >= n) {
          throw ArgumentError('Invalid neighbor $neighbor for vertex $i');
        }
      }
    }
    
    // Handle single vertex
    if (n == 1) {
      return graph[0].contains(0) ? [[0]] : [[0]];
    }
    
    // Use Tarjan's algorithm
    TarjanSCC scc = TarjanSCC(n);
    for (int i = 0; i < n; i++) {
      for (int neighbor in graph[i]) {
        scc.addEdge(i, neighbor);
      }
    }
    
    return scc.findSCCs();
  }
  
  static bool validateSCCResult(List<List<int>> sccs, int numVertices) {
    Set<int> allVertices = {};
    
    for (List<int> scc in sccs) {
      if (scc.isEmpty) return false;
      
      for (int vertex in scc) {
        if (vertex < 0 || vertex >= numVertices) return false;
        if (allVertices.contains(vertex)) return false; // Duplicate vertex
        allVertices.add(vertex);
      }
    }
    
    return allVertices.length == numVertices;
  }
}
```

### 4. Testing and Validation

```dart
class SCCTester {
  static void runTests() {
    print('Running SCC Algorithm Tests...');
    
    _testBasicSCC();
    _testSingleVertex();
    _testDisconnectedGraph();
    _testLargeSCC();
    _testAlgorithmConsistency();
    
    print('All tests passed!');
  }
  
  static void _testBasicSCC() {
    TarjanSCC scc = TarjanSCC(4);
    scc.addEdge(0, 1);
    scc.addEdge(1, 2);
    scc.addEdge(2, 0);
    scc.addEdge(2, 3);
    
    List<List<int>> result = scc.findSCCs();
    assert(result.length == 2);
    assert(result.any((component) => component.length == 3)); // {0, 1, 2}
    assert(result.any((component) => component.length == 1)); // {3}
  }
  
  static void _testSingleVertex() {
    TarjanSCC scc = TarjanSCC(1);
    List<List<int>> result = scc.findSCCs();
    assert(result.length == 1);
    assert(result[0].length == 1);
    assert(result[0][0] == 0);
  }
  
  static void _testDisconnectedGraph() {
    TarjanSCC scc = TarjanSCC(4);
    scc.addEdge(0, 1);
    scc.addEdge(2, 3);
    
    List<List<int>> result = scc.findSCCs();
    assert(result.length == 4); // Each vertex is its own SCC
  }
  
  static void _testLargeSCC() {
    int n = 1000;
    TarjanSCC scc = TarjanSCC(n);
    
    // Create a large cycle
    for (int i = 0; i < n; i++) {
      scc.addEdge(i, (i + 1) % n);
    }
    
    List<List<int>> result = scc.findSCCs();
    assert(result.length == 1);
    assert(result[0].length == n);
  }
  
  static void _testAlgorithmConsistency() {
    int n = 10;
    List<List<int>> graph = List.generate(n, (_) => <int>[]);
    
    // Build random graph
    math.Random random = math.Random(42); // Fixed seed for reproducibility
    for (int i = 0; i < 20; i++) {
      int from = random.nextInt(n);
      int to = random.nextInt(n);
      graph[from].add(to);
    }
    
    // Test Kosaraju
    KosarajuSCC kosaraju = KosarajuSCC(n);
    for (int i = 0; i < n; i++) {
      for (int neighbor in graph[i]) {
        kosaraju.addEdge(i, neighbor);
      }
    }
    List<List<int>> kosarajuResult = kosaraju.findSCCs();
    
    // Test Tarjan
    TarjanSCC tarjan = TarjanSCC(n);
    for (int i = 0; i < n; i++) {
      for (int neighbor in graph[i]) {
        tarjan.addEdge(i, neighbor);
      }
    }
    List<List<int>> tarjanResult = tarjan.findSCCs();
    
    // Results should have same number of SCCs
    assert(kosarajuResult.length == tarjanResult.length);
    
    // Each vertex should appear in exactly one SCC in both results
    assert(SCCEdgeCaseHandler.validateSCCResult(kosarajuResult, n));
    assert(SCCEdgeCaseHandler.validateSCCResult(tarjanResult, n));
  }
}
```

Strongly Connected Components are fundamental in graph theory and have wide applications in computer science, from compiler optimization to social network analysis. The key insight is that SCCs represent groups of vertices that are mutually reachable, which often corresponds to meaningful clusters or cycles in real-world problems. Mastering SCC algorithms, particularly Tarjan's algorithm for its efficiency, is essential for solving complex graph problems on LeetCode and in practice.