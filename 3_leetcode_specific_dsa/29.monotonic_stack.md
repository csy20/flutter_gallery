# Monotonic Stack

## Table of Contents
1. [What is a Monotonic Stack?](#what-is-a-monotonic-stack)
2. [How Monotonic Stack Works](#how-monotonic-stack-works)
3. [Types of Monotonic Stacks](#types-of-monotonic-stacks)
4. [When to Use Monotonic Stack](#when-to-use-monotonic-stack)
5. [Implementation Patterns](#implementation-patterns)
6. [Classic LeetCode Problems](#classic-leetcode-problems)
7. [Advanced Problems](#advanced-problems)
8. [Templates and Patterns](#templates-and-patterns)
9. [Time and Space Complexity](#time-and-space-complexity)
10. [Tips and Tricks](#tips-and-tricks)

## What is a Monotonic Stack?

A **Monotonic Stack** is a stack data structure where elements are maintained in a specific order - either strictly increasing (monotonic increasing) or strictly decreasing (monotonic decreasing). When a new element violates the monotonic property, elements are popped from the stack until the property is restored.

### üéØ Key Characteristics:
- **Maintains order**: Elements follow a specific ordering pattern
- **Efficient queries**: Finds next/previous greater/smaller elements efficiently
- **Single pass**: Most problems can be solved in O(n) time
- **Space efficient**: Uses O(n) space in worst case

### üìä Visual Example:

```dart
// Monotonic Increasing Stack Example
// Input: [3, 1, 4, 1, 5, 9, 2, 6]

void demonstrateMonotonicStack() {
  List<int> nums = [3, 1, 4, 1, 5, 9, 2, 6];
  List<int> stack = [];
  
  print('=== Monotonic Increasing Stack Demo ===');
  
  for (int i = 0; i < nums.length; i++) {
    print('\nProcessing ${nums[i]} at index $i:');
    
    // Pop elements that violate monotonic increasing property
    while (stack.isNotEmpty && nums[stack.last] > nums[i]) {
      int poppedIndex = stack.removeLast();
      print('  Popped: ${nums[poppedIndex]} (index $poppedIndex)');
    }
    
    stack.add(i);
    print('  Stack indices: $stack');
    print('  Stack values: ${stack.map((idx) => nums[idx]).toList()}');
  }
  
  print('\nFinal monotonic increasing stack: ${stack.map((idx) => nums[idx]).toList()}');
}
```

## How Monotonic Stack Works

### üîÑ Core Algorithm:

```dart
class MonotonicStackExplainer {
  // Monotonic Increasing Stack
  static List<int> monotonicIncreasing(List<int> nums) {
    List<int> stack = [];
    List<String> operations = [];
    
    print('=== Building Monotonic Increasing Stack ===');
    
    for (int i = 0; i < nums.length; i++) {
      operations.add('Step ${i + 1}: Processing ${nums[i]}');
      
      // Remove elements that are greater than current element
      while (stack.isNotEmpty && stack.last > nums[i]) {
        int popped = stack.removeLast();
        operations.add('  - Popped $popped (violates increasing order)');
      }
      
      stack.add(nums[i]);
      operations.add('  - Added ${nums[i]}, Stack: $stack');
    }
    
    operations.forEach(print);
    return stack;
  }
  
  // Monotonic Decreasing Stack
  static List<int> monotonicDecreasing(List<int> nums) {
    List<int> stack = [];
    List<String> operations = [];
    
    print('\n=== Building Monotonic Decreasing Stack ===');
    
    for (int i = 0; i < nums.length; i++) {
      operations.add('Step ${i + 1}: Processing ${nums[i]}');
      
      // Remove elements that are smaller than current element
      while (stack.isNotEmpty && stack.last < nums[i]) {
        int popped = stack.removeLast();
        operations.add('  - Popped $popped (violates decreasing order)');
      }
      
      stack.add(nums[i]);
      operations.add('  - Added ${nums[i]}, Stack: $stack');
    }
    
    operations.forEach(print);
    return stack;
  }
  
  static void demonstrateComparison() {
    List<int> nums = [4, 3, 2, 5, 1, 8, 6];
    print('Input: $nums\n');
    
    List<int> increasing = monotonicIncreasing(nums);
    List<int> decreasing = monotonicDecreasing(nums);
    
    print('\nResults:');
    print('Monotonic Increasing: $increasing');
    print('Monotonic Decreasing: $decreasing');
  }
}
```

### üéØ Step-by-Step Process:

1. **Initialize**: Create empty stack
2. **Iterate**: Process each element in the array
3. **Check**: Compare current element with stack top
4. **Pop**: Remove elements that violate monotonic property
5. **Push**: Add current element to stack
6. **Repeat**: Continue until all elements processed

## Types of Monotonic Stacks

### 1. **Monotonic Increasing Stack**

```dart
class MonotonicIncreasingStack {
  static List<int> findNextGreaterElement(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Stack stores indices
    
    print('=== Finding Next Greater Element ===');
    
    for (int i = 0; i < n; i++) {
      print('\nProcessing nums[$i] = ${nums[i]}');
      
      // Pop elements smaller than current element
      while (stack.isNotEmpty && nums[stack.last] < nums[i]) {
        int index = stack.removeLast();
        result[index] = nums[i];
        print('  Next greater for nums[$index] = ${nums[index]} is ${nums[i]}');
      }
      
      stack.add(i);
      print('  Stack indices: $stack');
    }
    
    print('\nResult: $result');
    return result;
  }
  
  static void demonstrate() {
    List<int> nums = [2, 1, 2, 4, 3, 1];
    print('Input: $nums');
    findNextGreaterElement(nums);
    
    // Expected output: [4, 2, 4, -1, -1, -1]
    // nums[0] = 2, next greater = 4
    // nums[1] = 1, next greater = 2
    // nums[2] = 2, next greater = 4
    // nums[3] = 4, no next greater = -1
    // nums[4] = 3, no next greater = -1
    // nums[5] = 1, no next greater = -1
  }
}
```

### 2. **Monotonic Decreasing Stack**

```dart
class MonotonicDecreasingStack {
  static List<int> findNextSmallerElement(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Stack stores indices
    
    print('=== Finding Next Smaller Element ===');
    
    for (int i = 0; i < n; i++) {
      print('\nProcessing nums[$i] = ${nums[i]}');
      
      // Pop elements greater than current element
      while (stack.isNotEmpty && nums[stack.last] > nums[i]) {
        int index = stack.removeLast();
        result[index] = nums[i];
        print('  Next smaller for nums[$index] = ${nums[index]} is ${nums[i]}');
      }
      
      stack.add(i);
      print('  Stack indices: $stack');
    }
    
    print('\nResult: $result');
    return result;
  }
  
  static void demonstrate() {
    List<int> nums = [4, 3, 2, 1, 2, 5];
    print('Input: $nums');
    findNextSmallerElement(nums);
    
    // Expected output: [3, 2, 1, -1, -1, -1]
    // nums[0] = 4, next smaller = 3
    // nums[1] = 3, next smaller = 2
    // nums[2] = 2, next smaller = 1
    // nums[3] = 1, no next smaller = -1
    // nums[4] = 2, no next smaller = -1
    // nums[5] = 5, no next smaller = -1
  }
}
```

## When to Use Monotonic Stack

### üéØ Common Problem Patterns:

1. **Next/Previous Greater Element**
2. **Next/Previous Smaller Element**
3. **Largest Rectangle in Histogram**
4. **Daily Temperatures**
5. **Stock Span Problem**
6. **Trapping Rain Water**
7. **Maximum Rectangle**

### üîç Problem Recognition Signals:

```dart
class ProblemRecognition {
  // Signal 1: Finding next/previous greater/smaller elements
  static bool isNextGreaterProblem(String problemDescription) {
    List<String> keywords = [
      'next greater', 'next larger', 'previous greater',
      'next smaller', 'previous smaller', 'nearest larger',
      'nearest smaller', 'daily temperatures'
    ];
    
    return keywords.any((keyword) => 
        problemDescription.toLowerCase().contains(keyword));
  }
  
  // Signal 2: Histogram/Rectangle problems
  static bool isHistogramProblem(String problemDescription) {
    List<String> keywords = [
      'histogram', 'rectangle', 'largest area',
      'maximum area', 'bar chart', 'building heights'
    ];
    
    return keywords.any((keyword) => 
        problemDescription.toLowerCase().contains(keyword));
  }
  
  // Signal 3: Water trapping problems
  static bool isWaterTrappingProblem(String problemDescription) {
    List<String> keywords = [
      'trap water', 'rain water', 'water trapped',
      'container', 'elevation map'
    ];
    
    return keywords.any((keyword) => 
        problemDescription.toLowerCase().contains(keyword));
  }
  
  static void analyzeProblem(String description) {
    print('Problem Analysis: "$description"');
    
    if (isNextGreaterProblem(description)) {
      print('‚úÖ Likely a Next/Previous Greater/Smaller problem');
      print('üí° Consider using Monotonic Stack');
    }
    
    if (isHistogramProblem(description)) {
      print('‚úÖ Likely a Histogram/Rectangle problem');
      print('üí° Consider using Monotonic Stack for largest rectangle');
    }
    
    if (isWaterTrappingProblem(description)) {
      print('‚úÖ Likely a Water Trapping problem');
      print('üí° Consider using Monotonic Stack or Two Pointers');
    }
  }
}
```

## Implementation Patterns

### 1. **Basic Monotonic Stack Template**

```dart
class MonotonicStackTemplate {
  // Template for Next Greater Element pattern
  static List<int> nextGreaterElementTemplate(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic decreasing stack (stores indices)
    
    for (int i = 0; i < n; i++) {
      // Pop elements while stack is not empty and 
      // top element is smaller than current element
      while (stack.isNotEmpty && nums[stack.last] < nums[i]) {
        int index = stack.removeLast();
        result[index] = nums[i]; // Found next greater element
      }
      
      stack.add(i); // Add current index to stack
    }
    
    return result;
  }
  
  // Template for Previous Greater Element pattern
  static List<int> previousGreaterElementTemplate(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic decreasing stack
    
    for (int i = 0; i < n; i++) {
      // Pop elements while stack is not empty and 
      // top element is smaller than or equal to current element
      while (stack.isNotEmpty && nums[stack.last] <= nums[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        result[i] = nums[stack.last]; // Found previous greater element
      }
      
      stack.add(i);
    }
    
    return result;
  }
  
  // Template for Next Smaller Element pattern
  static List<int> nextSmallerElementTemplate(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic increasing stack
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && nums[stack.last] > nums[i]) {
        int index = stack.removeLast();
        result[index] = nums[i];
      }
      
      stack.add(i);
    }
    
    return result;
  }
}
```

### 2. **Advanced Pattern: Circular Array**

```dart
class CircularArrayPattern {
  // Next Greater Element in Circular Array
  static List<int> nextGreaterElementsCircular(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = [];
    
    print('=== Next Greater Elements in Circular Array ===');
    print('Input: $nums');
    
    // Process array twice to handle circular nature
    for (int i = 0; i < 2 * n; i++) {
      int currentIndex = i % n;
      int currentValue = nums[currentIndex];
      
      print('\nIteration $i: Processing nums[$currentIndex] = $currentValue');
      
      while (stack.isNotEmpty && nums[stack.last] < currentValue) {
        int index = stack.removeLast();
        if (result[index] == -1) { // Only set if not already set
          result[index] = currentValue;
          print('  Found next greater for nums[$index] = ${nums[index]} is $currentValue');
        }
      }
      
      if (i < n) { // Only add to stack in first pass
        stack.add(currentIndex);
      }
      
      print('  Stack: $stack');
      print('  Result so far: $result');
    }
    
    print('\nFinal result: $result');
    return result;
  }
  
  static void demonstrate() {
    List<int> nums = [1, 2, 1];
    nextGreaterElementsCircular(nums);
    // Expected: [2, -1, 2]
    // For nums[0] = 1, next greater is 2
    // For nums[1] = 2, no next greater (even in circular)
    // For nums[2] = 1, next greater is 2 (circular)
  }
}
```

## Classic LeetCode Problems

### 1. **Problem 496: Next Greater Element I**

```dart
class NextGreaterElementI {
  /*
  Problem: Given two distinct arrays nums1 and nums2, where nums1 is a subset of nums2.
  Find all the next greater numbers for nums1's elements in the corresponding places of nums2.
  
  Example:
  Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
  Output: [-1,3,-1]
  
  Explanation:
  - For number 4 in nums1, cannot find next greater in nums2, so -1
  - For number 1 in nums1, next greater in nums2 is 3
  - For number 2 in nums1, cannot find next greater in nums2, so -1
  */
  
  static List<int> nextGreaterElement(List<int> nums1, List<int> nums2) {
    // Step 1: Build next greater map for nums2
    Map<int, int> nextGreaterMap = {};
    List<int> stack = [];
    
    print('=== Building Next Greater Map for nums2 ===');
    print('nums2: $nums2');
    
    for (int i = 0; i < nums2.length; i++) {
      print('\nProcessing ${nums2[i]}:');
      
      while (stack.isNotEmpty && stack.last < nums2[i]) {
        int smaller = stack.removeLast();
        nextGreaterMap[smaller] = nums2[i];
        print('  Next greater for $smaller is ${nums2[i]}');
      }
      
      stack.add(nums2[i]);
      print('  Stack: $stack');
    }
    
    print('\nNext Greater Map: $nextGreaterMap');
    
    // Step 2: Build result for nums1
    List<int> result = [];
    for (int num in nums1) {
      result.add(nextGreaterMap[num] ?? -1);
    }
    
    print('\nResult for nums1 $nums1: $result');
    return result;
  }
  
  static void test() {
    print('=== LeetCode 496: Next Greater Element I ===');
    
    // Test case 1
    List<int> nums1 = [4, 1, 2];
    List<int> nums2 = [1, 3, 4, 2];
    List<int> result1 = nextGreaterElement(nums1, nums2);
    print('Test 1 - Expected: [-1, 3, -1], Got: $result1\n');
    
    // Test case 2
    nums1 = [2, 4];
    nums2 = [1, 2, 3, 4];
    List<int> result2 = nextGreaterElement(nums1, nums2);
    print('Test 2 - Expected: [3, -1], Got: $result2');
  }
}
```

### 2. **Problem 503: Next Greater Element II (Circular Array)**

```dart
class NextGreaterElementII {
  /*
  Problem: Given a circular integer array nums, return the next greater number 
  for every element in nums. If it doesn't exist, return -1 for this number.
  
  Example:
  Input: nums = [1,2,1]
  Output: [2,-1,2]
  
  Explanation:
  - First 1's next greater is 2
  - Number 2 has no next greater (even considering circular)
  - Second 1's next greater is 2 (circular)
  */
  
  static List<int> nextGreaterElements(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Store indices
    
    print('=== LeetCode 503: Next Greater Element II ===');
    print('Input: $nums');
    
    // Process array twice to handle circular nature
    for (int i = 0; i < 2 * n; i++) {
      int currentIndex = i % n;
      
      print('\nIteration $i: nums[${i % n}] = ${nums[currentIndex]}');
      
      while (stack.isNotEmpty && nums[stack.last] < nums[currentIndex]) {
        int index = stack.removeLast();
        result[index] = nums[currentIndex];
        print('  Found next greater for nums[$index] = ${nums[index]} is ${nums[currentIndex]}');
      }
      
      // Only add to stack in first pass
      if (i < n) {
        stack.add(currentIndex);
      }
      
      print('  Stack: $stack');
      print('  Result: $result');
    }
    
    print('\nFinal result: $result');
    return result;
  }
  
  static void test() {
    // Test case 1
    List<int> nums1 = [1, 2, 1];
    List<int> result1 = nextGreaterElements(nums1);
    print('Expected: [2, -1, 2], Got: $result1\n');
    
    // Test case 2
    List<int> nums2 = [1, 2, 3, 4, 3];
    List<int> result2 = nextGreaterElements(nums2);
    print('Expected: [2, 3, 4, -1, 4], Got: $result2');
  }
}
```

### 3. **Problem 739: Daily Temperatures**

```dart
class DailyTemperatures {
  /*
  Problem: Given an array of integers temperatures represents the daily temperatures,
  return an array answer such that answer[i] is the number of days you have to wait
  after the ith day to get a warmer temperature.
  
  Example:
  Input: temperatures = [73,74,75,71,69,72,76,73]
  Output: [1,1,4,2,1,1,0,0]
  
  Explanation:
  - Day 0 (73¬∞): Next warmer day is day 1 (74¬∞), so wait 1 day
  - Day 1 (74¬∞): Next warmer day is day 2 (75¬∞), so wait 1 day
  - Day 2 (75¬∞): Next warmer day is day 6 (76¬∞), so wait 4 days
  - etc.
  */
  
  static List<int> dailyTemperatures(List<int> temperatures) {
    int n = temperatures.length;
    List<int> result = List.filled(n, 0);
    List<int> stack = []; // Store indices of temperatures
    
    print('=== LeetCode 739: Daily Temperatures ===');
    print('Temperatures: $temperatures');
    
    for (int i = 0; i < n; i++) {
      print('\nDay $i: ${temperatures[i]}¬∞');
      
      // Pop days with lower temperatures and update their waiting days
      while (stack.isNotEmpty && temperatures[stack.last] < temperatures[i]) {
        int prevDay = stack.removeLast();
        int waitingDays = i - prevDay;
        result[prevDay] = waitingDays;
        print('  Day $prevDay (${temperatures[prevDay]}¬∞) waits $waitingDays days for day $i (${temperatures[i]}¬∞)');
      }
      
      stack.add(i);
      print('  Stack (days): $stack');
      print('  Result: $result');
    }
    
    print('\nFinal result: $result');
    return result;
  }
  
  static void test() {
    List<int> temperatures = [73, 74, 75, 71, 69, 72, 76, 73];
    List<int> result = dailyTemperatures(temperatures);
    print('Expected: [1, 1, 4, 2, 1, 1, 0, 0]');
    print('Got:      $result');
  }
}
```

### 4. **Problem 84: Largest Rectangle in Histogram**

```dart
class LargestRectangleInHistogram {
  /*
  Problem: Given an array of integers heights representing the histogram's bar height
  where the width of each bar is 1, return the area of the largest rectangle in the histogram.
  
  Example:
  Input: heights = [2,1,5,6,2,3]
  Output: 10
  
  The largest rectangle has area = 10 (width=2, height=5, positions 2-3)
  */
  
  static int largestRectangleArea(List<int> heights) {
    List<int> stack = []; // Store indices
    int maxArea = 0;
    int n = heights.length;
    
    print('=== LeetCode 84: Largest Rectangle in Histogram ===');
    print('Heights: $heights');
    
    for (int i = 0; i <= n; i++) {
      // Use 0 as sentinel value for last iteration
      int currentHeight = (i == n) ? 0 : heights[i];
      
      print('\nProcessing index $i, height: $currentHeight');
      
      while (stack.isNotEmpty && heights[stack.last] > currentHeight) {
        int height = heights[stack.removeLast()];
        int width = stack.isEmpty ? i : i - stack.last - 1;
        int area = height * width;
        
        print('  Calculating rectangle:');
        print('    Height: $height');
        print('    Width: $width (from ${stack.isEmpty ? 0 : stack.last + 1} to ${i - 1})');
        print('    Area: $area');
        
        maxArea = maxArea > area ? maxArea : area;
        print('    Max area so far: $maxArea');
      }
      
      if (i < n) {
        stack.add(i);
      }
      
      print('  Stack: $stack');
    }
    
    print('\nLargest rectangle area: $maxArea');
    return maxArea;
  }
  
  // Alternative approach with clearer explanation
  static int largestRectangleAreaDetailed(List<int> heights) {
    int n = heights.length;
    
    // Find previous smaller element for each bar
    List<int> prevSmaller = List.filled(n, -1);
    List<int> stack = [];
    
    print('\n=== Finding Previous Smaller Elements ===');
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && heights[stack.last] >= heights[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        prevSmaller[i] = stack.last;
      }
      
      stack.add(i);
    }
    print('Previous smaller indices: $prevSmaller');
    
    // Find next smaller element for each bar
    List<int> nextSmaller = List.filled(n, n);
    stack.clear();
    
    print('\n=== Finding Next Smaller Elements ===');
    for (int i = n - 1; i >= 0; i--) {
      while (stack.isNotEmpty && heights[stack.last] >= heights[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        nextSmaller[i] = stack.last;
      }
      
      stack.add(i);
    }
    print('Next smaller indices: $nextSmaller');
    
    // Calculate maximum area
    int maxArea = 0;
    print('\n=== Calculating Areas ===');
    
    for (int i = 0; i < n; i++) {
      int height = heights[i];
      int width = nextSmaller[i] - prevSmaller[i] - 1;
      int area = height * width;
      
      print('Bar $i: height=$height, width=$width, area=$area');
      maxArea = maxArea > area ? maxArea : area;
    }
    
    return maxArea;
  }
  
  static void test() {
    // Test case 1
    List<int> heights1 = [2, 1, 5, 6, 2, 3];
    int result1 = largestRectangleArea(heights1);
    print('\nTest 1 - Expected: 10, Got: $result1');
    
    // Test case 2 - detailed approach
    print('\n' + '=' * 50);
    List<int> heights2 = [2, 4];
    int result2 = largestRectangleAreaDetailed(heights2);
    print('\nTest 2 - Expected: 4, Got: $result2');
  }
}
```

### 5. **Problem 42: Trapping Rain Water**

```dart
class TrappingRainWater {
  /*
  Problem: Given n non-negative integers representing an elevation map where
  the width of each bar is 1, compute how much water it can trap after raining.
  
  Example:
  Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
  Output: 6
  
  The above elevation map can trap 6 units of rain water.
  */
  
  // Approach 1: Using Monotonic Decreasing Stack
  static int trapUsingStack(List<int> height) {
    List<int> stack = []; // Store indices
    int water = 0;
    
    print('=== Trapping Rain Water using Monotonic Stack ===');
    print('Heights: $height');
    
    for (int i = 0; i < height.length; i++) {
      print('\nProcessing index $i, height: ${height[i]}');
      
      while (stack.isNotEmpty && height[i] > height[stack.last]) {
        int top = stack.removeLast();
        
        if (stack.isEmpty) {
          print('  No left boundary for index $top');
          break;
        }
        
        int distance = i - stack.last - 1;
        int boundedHeight = (height[i] < height[stack.last] ? height[i] : height[stack.last]) - height[top];
        int trappedWater = distance * boundedHeight;
        
        print('  Water trapped between indices ${stack.last} and $i:');
        print('    Distance: $distance');
        print('    Bounded height: $boundedHeight');
        print('    Water: $trappedWater');
        
        water += trappedWater;
      }
      
      stack.add(i);
      print('  Stack: $stack');
      print('  Total water: $water');
    }
    
    print('\nTotal trapped water: $water');
    return water;
  }
  
  // Approach 2: Two Pointers (for comparison)
  static int trapTwoPointers(List<int> height) {
    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    print('\n=== Trapping Rain Water using Two Pointers ===');
    
    while (left < right) {
      if (height[left] < height[right]) {
        if (height[left] >= leftMax) {
          leftMax = height[left];
        } else {
          int trapped = leftMax - height[left];
          water += trapped;
          print('At index $left: trapped $trapped units (leftMax=$leftMax, height=${height[left]})');
        }
        left++;
      } else {
        if (height[right] >= rightMax) {
          rightMax = height[right];
        } else {
          int trapped = rightMax - height[right];
          water += trapped;
          print('At index $right: trapped $trapped units (rightMax=$rightMax, height=${height[right]})');
        }
        right--;
      }
    }
    
    return water;
  }
  
  static void test() {
    List<int> height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1];
    
    int result1 = trapUsingStack(height);
    int result2 = trapTwoPointers(height);
    
    print('\nComparison:');
    print('Stack approach: $result1');
    print('Two pointers: $result2');
    print('Expected: 6');
  }
}
```

## Advanced Problems

### 1. **Problem 85: Maximal Rectangle**

```dart
class MaximalRectangle {
  /*
  Problem: Given a rows x cols binary matrix filled with 0's and 1's,
  find the largest rectangle containing only 1's and return its area.
  
  Example:
  Input: matrix = [
    ["1","0","1","0","0"],
    ["1","0","1","1","1"],
    ["1","1","1","1","1"],
    ["1","0","0","1","0"]
  ]
  Output: 6 (the 2x3 rectangle in the bottom-right)
  */
  
  static int maximalRectangle(List<List<String>> matrix) {
    if (matrix.isEmpty || matrix[0].isEmpty) return 0;
    
    int rows = matrix.length;
    int cols = matrix[0].length;
    List<int> heights = List.filled(cols, 0);
    int maxArea = 0;
    
    print('=== LeetCode 85: Maximal Rectangle ===');
    print('Matrix:');
    for (int i = 0; i < rows; i++) {
      print('  ${matrix[i]}');
    }
    
    for (int i = 0; i < rows; i++) {
      // Update heights for current row
      for (int j = 0; j < cols; j++) {
        heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;
      }
      
      print('\nRow $i heights: $heights');
      
      // Find largest rectangle in histogram for this row
      int area = largestRectangleInHistogram(heights);
      maxArea = maxArea > area ? maxArea : area;
      
      print('Largest rectangle area for row $i: $area');
      print('Max area so far: $maxArea');
    }
    
    return maxArea;
  }
  
  static int largestRectangleInHistogram(List<int> heights) {
    List<int> stack = [];
    int maxArea = 0;
    int n = heights.length;
    
    for (int i = 0; i <= n; i++) {
      int h = (i == n) ? 0 : heights[i];
      
      while (stack.isNotEmpty && heights[stack.last] > h) {
        int height = heights[stack.removeLast()];
        int width = stack.isEmpty ? i : i - stack.last - 1;
        int area = height * width;
        maxArea = maxArea > area ? maxArea : area;
      }
      
      if (i < n) {
        stack.add(i);
      }
    }
    
    return maxArea;
  }
  
  static void test() {
    List<List<String>> matrix = [
      ["1", "0", "1", "0", "0"],
      ["1", "0", "1", "1", "1"],
      ["1", "1", "1", "1", "1"],
      ["1", "0", "0", "1", "0"]
    ];
    
    int result = maximalRectangle(matrix);
    print('\nFinal result: $result');
    print('Expected: 6');
  }
}
```

### 2. **Problem 907: Sum of Subarray Minimums**

```dart
class SumOfSubarrayMinimums {
  /*
  Problem: Given an array of integers arr, find the sum of min(b),
  where b ranges over every (contiguous) subarray of arr.
  
  Example:
  Input: arr = [3,1,2,4]
  Output: 17
  
  Explanation:
  Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]
  Minimums are: 3,   1,   2,   4,    1,     1,     2,      1,       1,       1
  Sum is: 3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17
  */
  
  static int sumSubarrayMins(List<int> arr) {
    const int MOD = 1000000007;
    int n = arr.length;
    
    // Find previous less element
    List<int> prevLess = List.filled(n, -1);
    List<int> stack = [];
    
    print('=== Finding Previous Less Elements ===');
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && arr[stack.last] > arr[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        prevLess[i] = stack.last;
      }
      
      stack.add(i);
    }
    print('Previous less: $prevLess');
    
    // Find next less element
    List<int> nextLess = List.filled(n, n);
    stack.clear();
    
    print('\n=== Finding Next Less Elements ===');
    for (int i = n - 1; i >= 0; i--) {
      while (stack.isNotEmpty && arr[stack.last] >= arr[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        nextLess[i] = stack.last;
      }
      
      stack.add(i);
    }
    print('Next less: $nextLess');
    
    // Calculate contribution of each element
    int result = 0;
    print('\n=== Calculating Contributions ===');
    
    for (int i = 0; i < n; i++) {
      int left = i - prevLess[i];  // Number of subarrays where arr[i] is minimum from left
      int right = nextLess[i] - i; // Number of subarrays where arr[i] is minimum from right
      int contribution = (arr[i] * left % MOD * right % MOD) % MOD;
      
      print('Element ${arr[i]} at index $i:');
      print('  Left count: $left');
      print('  Right count: $right');
      print('  Contribution: $contribution');
      
      result = (result + contribution) % MOD;
    }
    
    print('\nTotal sum: $result');
    return result;
  }
  
  static void test() {
    print('=== LeetCode 907: Sum of Subarray Minimums ===');
    
    List<int> arr = [3, 1, 2, 4];
    print('Input: $arr');
    
    int result = sumSubarrayMins(arr);
    print('\nExpected: 17, Got: $result');
  }
}
```

## Templates and Patterns

### 1. **Universal Monotonic Stack Template**

```dart
class MonotonicStackTemplates {
  // Template 1: Next Greater Element
  static List<int> nextGreater(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic decreasing
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && nums[stack.last] < nums[i]) {
        result[stack.removeLast()] = nums[i];
      }
      stack.add(i);
    }
    return result;
  }
  
  // Template 2: Previous Greater Element
  static List<int> previousGreater(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic decreasing
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && nums[stack.last] <= nums[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        result[i] = nums[stack.last];
      }
      
      stack.add(i);
    }
    return result;
  }
  
  // Template 3: Next Smaller Element
  static List<int> nextSmaller(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic increasing
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && nums[stack.last] > nums[i]) {
        result[stack.removeLast()] = nums[i];
      }
      stack.add(i);
    }
    return result;
  }
  
  // Template 4: Previous Smaller Element
  static List<int> previousSmaller(List<int> nums) {
    int n = nums.length;
    List<int> result = List.filled(n, -1);
    List<int> stack = []; // Monotonic increasing
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && nums[stack.last] >= nums[i]) {
        stack.removeLast();
      }
      
      if (stack.isNotEmpty) {
        result[i] = nums[stack.last];
      }
      
      stack.add(i);
    }
    return result;
  }
  
  // Template 5: Generic Monotonic Stack
  static List<int> monotonicStack<T>(
    List<T> nums,
    bool Function(T a, T b) shouldPop,
    T Function(T value, int index) transform,
    T defaultValue,
  ) {
    int n = nums.length;
    List<T> result = List.filled(n, defaultValue);
    List<int> stack = [];
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && shouldPop(nums[stack.last], nums[i])) {
        int index = stack.removeLast();
        result[index] = transform(nums[i], i);
      }
      stack.add(i);
    }
    
    return result.cast<int>();
  }
}
```

### 2. **Problem-Specific Templates**

```dart
class ProblemSpecificTemplates {
  // Template for Histogram problems
  static int largestRectangleTemplate(List<int> heights) {
    List<int> stack = [];
    int maxArea = 0;
    int n = heights.length;
    
    for (int i = 0; i <= n; i++) {
      int h = (i == n) ? 0 : heights[i];
      
      while (stack.isNotEmpty && heights[stack.last] > h) {
        int height = heights[stack.removeLast()];
        int width = stack.isEmpty ? i : i - stack.last - 1;
        maxArea = maxArea.compareTo(height * width) > 0 ? maxArea : height * width;
      }
      
      if (i < n) stack.add(i);
    }
    
    return maxArea;
  }
  
  // Template for Water Trapping problems
  static int trapWaterTemplate(List<int> heights) {
    List<int> stack = [];
    int water = 0;
    
    for (int i = 0; i < heights.length; i++) {
      while (stack.isNotEmpty && heights[i] > heights[stack.last]) {
        int top = stack.removeLast();
        if (stack.isEmpty) break;
        
        int distance = i - stack.last - 1;
        int boundedHeight = (heights[i] < heights[stack.last] ? heights[i] : heights[stack.last]) - heights[top];
        water += distance * boundedHeight;
      }
      stack.add(i);
    }
    
    return water;
  }
  
  // Template for Contribution problems
  static int contributionTemplate(List<int> arr) {
    int n = arr.length;
    
    // Previous less
    List<int> prevLess = List.filled(n, -1);
    List<int> stack = [];
    
    for (int i = 0; i < n; i++) {
      while (stack.isNotEmpty && arr[stack.last] >= arr[i]) {
        stack.removeLast();
      }
      if (stack.isNotEmpty) prevLess[i] = stack.last;
      stack.add(i);
    }
    
    // Next less
    List<int> nextLess = List.filled(n, n);
    stack.clear();
    
    for (int i = n - 1; i >= 0; i--) {
      while (stack.isNotEmpty && arr[stack.last] >= arr[i]) {
        stack.removeLast();
      }
      if (stack.isNotEmpty) nextLess[i] = stack.last;
      stack.add(i);
    }
    
    // Calculate contribution
    int result = 0;
    for (int i = 0; i < n; i++) {
      int left = i - prevLess[i];
      int right = nextLess[i] - i;
      result += arr[i] * left * right;
    }
    
    return result;
  }
}
```

## Time and Space Complexity

### üìä Complexity Analysis:

```dart
class ComplexityAnalysis {
  /*
  Time Complexity: O(n)
  - Each element is pushed and popped at most once
  - Total operations: 2n (n pushes + n pops in worst case)
  - Amortized: O(1) per element
  
  Space Complexity: O(n)
  - Stack can contain all elements in worst case
  - Additional space for result array
  
  Examples of different scenarios:
  */
  
  static void analyzeComplexity() {
    print('=== Monotonic Stack Complexity Analysis ===');
    
    // Best case: Strictly increasing array
    List<int> increasing = [1, 2, 3, 4, 5];
    print('\nBest case (increasing): $increasing');
    print('- Each element pushed once, never popped until end');
    print('- Stack operations: n pushes');
    print('- Time: O(n), Space: O(n)');
    
    // Worst case: Strictly decreasing array
    List<int> decreasing = [5, 4, 3, 2, 1];
    print('\nWorst case (decreasing): $decreasing');
    print('- Each element pushed once, popped when smaller element found');
    print('- Stack operations: n pushes + (n-1) + (n-2) + ... + 1 pops = n + n(n-1)/2');
    print('- But each element is popped at most once, so total pops = n');
    print('- Time: O(n), Space: O(n)');
    
    // Average case: Random array
    List<int> random = [3, 1, 4, 1, 5, 9, 2, 6];
    print('\nAverage case (random): $random');
    print('- Mix of pushes and pops');
    print('- Each element pushed once, popped at most once');
    print('- Time: O(n), Space: O(n)');
    
    print('\nKey insight: Amortized analysis');
    print('- Even though inner while loop can run multiple times,');
    print('- each element is processed (pushed/popped) exactly once');
    print('- Total complexity remains O(n)');
  }
  
  static void demonstrateAmortization() {
    print('\n=== Amortized Analysis Demo ===');
    
    List<int> nums = [5, 4, 3, 2, 1, 6];
    List<int> stack = [];
    int pushOperations = 0;
    int popOperations = 0;
    
    print('Input: $nums');
    
    for (int i = 0; i < nums.length; i++) {
      print('\nProcessing ${nums[i]}:');
      
      while (stack.isNotEmpty && stack.last > nums[i]) {
        stack.removeLast();
        popOperations++;
        print('  Pop operation #$popOperations');
      }
      
      stack.add(nums[i]);
      pushOperations++;
      print('  Push operation #$pushOperations');
      print('  Stack: $stack');
    }
    
    print('\nTotal operations:');
    print('- Push operations: $pushOperations');
    print('- Pop operations: $popOperations');
    print('- Total: ${pushOperations + popOperations}');
    print('- Input size: ${nums.length}');
    print('- Ratio: ${(pushOperations + popOperations) / nums.length}');
  }
}
```

## Tips and Tricks

### üéØ Pro Tips for Monotonic Stack Problems:

```dart
class MonotonicStackTips {
  // Tip 1: Choose the right monotonic property
  static void tip1_ChooseMonotonicProperty() {
    print('=== Tip 1: Choose the Right Monotonic Property ===');
    print('');
    print('For NEXT GREATER problems:');
    print('  ‚úÖ Use DECREASING stack (pop smaller elements)');
    print('  üìù while (stack.isNotEmpty && nums[stack.last] < nums[i])');
    print('');
    print('For NEXT SMALLER problems:');
    print('  ‚úÖ Use INCREASING stack (pop larger elements)');
    print('  üìù while (stack.isNotEmpty && nums[stack.last] > nums[i])');
    print('');
    print('For PREVIOUS GREATER problems:');
    print('  ‚úÖ Use DECREASING stack, check before pushing');
    print('  üìù if (stack.isNotEmpty) result[i] = nums[stack.last]');
    print('');
    print('For PREVIOUS SMALLER problems:');
    print('  ‚úÖ Use INCREASING stack, check before pushing');
    print('');
  }
  
  // Tip 2: Store indices vs values
  static void tip2_StoreIndicesVsValues() {
    print('=== Tip 2: Store Indices vs Values ===');
    print('');
    print('Store INDICES when:');
    print('  ‚úÖ Need to calculate distances/widths');
    print('  ‚úÖ Need to access original array multiple times');
    print('  ‚úÖ Working with positions (like Daily Temperatures)');
    print('');
    print('Store VALUES when:');
    print('  ‚úÖ Only need the actual values');
    print('  ‚úÖ Simple next/previous element problems');
    print('  ‚úÖ Values are sufficient for computation');
    
    // Example: Why indices are better for Daily Temperatures
    List<int> temperatures = [73, 74, 75, 71, 69, 72, 76, 73];
    print('\nExample - Daily Temperatures: $temperatures');
    print('We need DAYS to wait, not just next temperature value');
    print('So we store indices to calculate: i - prevDay');
  }
  
  // Tip 3: Handle edge cases
  static void tip3_HandleEdgeCases() {
    print('\n=== Tip 3: Handle Edge Cases ===');
    print('');
    print('Common edge cases:');
    print('  üî∏ Empty array: Check array.isEmpty');
    print('  üî∏ Single element: Should work with standard logic');
    print('  üî∏ All elements equal: Handle <= vs < carefully');
    print('  üî∏ Strictly increasing: No pops until end');
    print('  üî∏ Strictly decreasing: Maximum pops');
    print('  üî∏ Circular arrays: Process twice, add only in first pass');
    
    // Demonstrate equal elements handling
    List<int> equalElements = [2, 2, 2, 2];
    print('\nExample - Equal elements: $equalElements');
    print('For next greater: No element has a next greater');
    print('For next smaller: No element has a next smaller');
    print('Important: Use < vs <= carefully based on problem requirements');
  }
  
  // Tip 4: Debugging techniques
  static void tip4_DebuggingTechniques() {
    print('\n=== Tip 4: Debugging Techniques ===');
    print('');
    print('Debug by printing:');
    print('  üîç Current element being processed');
    print('  üîç Stack state before/after operations');
    print('  üîç Elements being popped and why');
    print('  üîç Result array state');
    print('');
    print('Common bugs:');
    print('  üêõ Wrong comparison operator (< vs <=)');
    print('  üêõ Storing values instead of indices');
    print('  üêõ Not handling empty stack');
    print('  üêõ Wrong initialization of result array');
    print('  üêõ Off-by-one errors in width calculations');
  }
  
  // Tip 5: Optimization tricks
  static void tip5_OptimizationTricks() {
    print('\n=== Tip 5: Optimization Tricks ===');
    print('');
    print('Optimization techniques:');
    print('  ‚ö° Use List<int> instead of Stack<int> in Dart');
    print('  ‚ö° Reserve capacity: List<int>(n) for better performance');
    print('  ‚ö° Avoid unnecessary object creation');
    print('  ‚ö° Use indices to avoid array lookups when possible');
    print('  ‚ö° Combine multiple passes when possible');
    
    // Example: Optimized next greater element
    List<int> nums = [2, 1, 2, 4, 3, 1];
    List<int> result = List.filled(nums.length, -1);
    List<int> stack = <int>[]; // Pre-allocated
    
    for (int i = 0; i < nums.length; i++) {
      while (stack.isNotEmpty && nums[stack.last] < nums[i]) {
        result[stack.removeLast()] = nums[i];
      }
      stack.add(i);
    }
    
    print('\nOptimized implementation example completed');
  }
  
  // Tip 6: Pattern recognition
  static void tip6_PatternRecognition() {
    print('\n=== Tip 6: Pattern Recognition ===');
    print('');
    print('Recognize monotonic stack patterns:');
    print('  üìä "Next greater/smaller element" ‚Üí Direct monotonic stack');
    print('  üìä "Largest rectangle" ‚Üí Histogram pattern');
    print('  üìä "Trapping water" ‚Üí Two boundaries pattern');
    print('  üìä "Daily temperatures" ‚Üí Distance calculation');
    print('  üìä "Sum of minimums" ‚Üí Contribution pattern');
    print('');
    print('Key phrases that hint at monotonic stack:');
    print('  ‚ú® "next greater/larger"');
    print('  ‚ú® "previous smaller"');
    print('  ‚ú® "nearest larger"');
    print('  ‚ú® "histogram"');
    print('  ‚ú® "rectangle"');
    print('  ‚ú® "maximum area"');
    print('  ‚ú® "trapped water"');
    print('  ‚ú® "days to wait"');
  }
}
```

### üöÄ Complete Demo Function

```dart
// Main demonstration function
void main() {
  print('üéØ COMPREHENSIVE MONOTONIC STACK GUIDE üéØ\n');
  
  // Basic demonstration
  demonstrateMonotonicStack();
  print('\n${'=' * 60}\n');
  
  // Types comparison
  MonotonicStackExplainer.demonstrateComparison();
  print('\n${'=' * 60}\n');
  
  // Classic problems
  print('=== CLASSIC LEETCODE PROBLEMS ===\n');
  
  NextGreaterElementI.test();
  print('\n${'=' * 40}\n');
  
  NextGreaterElementII.test();
  print('\n${'=' * 40}\n');
  
  DailyTemperatures.test();
  print('\n${'=' * 40}\n');
  
  LargestRectangleInHistogram.test();
  print('\n${'=' * 40}\n');
  
  TrappingRainWater.test();
  print('\n${'=' * 60}\n');
  
  // Advanced problems
  print('=== ADVANCED PROBLEMS ===\n');
  
  MaximalRectangle.test();
  print('\n${'=' * 40}\n');
  
  SumOfSubarrayMinimums.test();
  print('\n${'=' * 60}\n');
  
  // Tips and analysis
  print('=== TIPS AND COMPLEXITY ANALYSIS ===\n');
  
  ComplexityAnalysis.analyzeComplexity();
  ComplexityAnalysis.demonstrateAmortization();
  
  print('\n${'=' * 60}\n');
  
  MonotonicStackTips.tip1_ChooseMonotonicProperty();
  MonotonicStackTips.tip2_StoreIndicesVsValues();
  MonotonicStackTips.tip3_HandleEdgeCases();
  MonotonicStackTips.tip4_DebuggingTechniques();
  MonotonicStackTips.tip5_OptimizationTricks();
  MonotonicStackTips.tip6_PatternRecognition();
  
  print('\nüéâ MONOTONIC STACK MASTERY COMPLETE! üéâ');
}
```

## Summary

### üéØ Key Takeaways:

1. **What**: Monotonic Stack maintains elements in sorted order (increasing/decreasing)
2. **When**: Next/Previous greater/smaller problems, histogram problems, water trapping
3. **How**: Pop violating elements, push current element
4. **Complexity**: O(n) time, O(n) space
5. **Patterns**: 
   - Decreasing stack ‚Üí Next/Previous greater
   - Increasing stack ‚Üí Next/Previous smaller
   - Histogram ‚Üí Largest rectangle pattern
   - Contribution ‚Üí Previous/Next boundaries

### üí° Master the Templates:
- Store **indices** for distance calculations
- Store **values** for simple lookups
- Use **circular array** technique for wraparound
- Apply **contribution** pattern for sum problems

### üèÜ Practice Problems:
- Start with basic next greater element
- Progress to daily temperatures
- Master largest rectangle in histogram
- Challenge yourself with advanced problems

This comprehensive guide covers everything you need to master Monotonic Stack problems in LeetCode interviews and competitive programming!
